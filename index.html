<!DOCTYPE html>
<html lang="en" class="">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta name="description" content="Stage Runner is an R package that helps with parametrizing and executing linear sequences of actions, common in the various stages of data analysis: data import, munging, modeling, export, and visualization.">

    <title>Parametrization and execution of linear sequences of actions</title>

    <link rel="stylesheet" media="all" href="stylesheets/rocco.css" />
    <link rel="stylesheet" media="all" href="stylesheets/github-markdown.css" />

    <script src="assets/highlight.pack.js"></script>
    <script type="text/javascript">
      hljs.initHighlightingOnLoad();
    </script>

    <style type="text/css">
      .header {
        position: fixed;
        top: 0px;
        width: 100%;
        background-color: #b3b3b3;
        padding:10px;
      }

      .container {
        margin-top: 40px;
      }

      body {
        padding: 0;
        margin: 0;
      }

      div.code-background {
        float: right;
        position: fixed;
        z-index: -1;
        height: 100%;
        background-color: #f8f8ff;
        width: 60%;
        right: 0px;
      }

      div.section {
        clear: both;
        margin: 0; padding: 0;
      }

      div.code {
        float: right;
        width: 60%;
      }

      code.R {
        font-size: 1.2em;
        line-height: 2em;
        margin-top: 0em;
        margin-bottom: -2em;
        padding-top: 0;
        margin-top: -1em;
      }

      code.R > span.spacer {
        position: relative;
      }

      div.code > pre {
        margin: 0;
        padding-left: 2em;
        margin-top: 0;
        margin-bottom: 0;
      }

      div.markdown {
        padding: 1em;
        padding-top: 0;
        background: #fff;
        float: left;
        width: 35%;
      }
    </style>

  </head>

  <body>
    <div class="header">
      <a href="https://github.com/robertzk/rocco">
        <img id="rocco-logo" src="https://img.shields.io/badge/Generated by rocco_v0.1.1-%E2%9C%93-blue.svg"/>
      </a>
    </div>
    <div class="container">

      <div class="code-background"></div>

        <div class="section">
          <div class="markdown markdown-body">
            <h1>boolean_fill.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>A stagerunner describes a <em>linear</em> sequence of execution: import data,
perform this munging step, then that munging, then do some modeling, etc.
However, it is structured hierarchically as a nested list for easier
usability. This function will create a nested list with the exact same
structure as the stagerunner except that each terminal node is either
<code>TRUE</code> or <code>FALSE</code>. </p>

<p>Specifically, given a tree structure with exactly one <code>TRUE</code> value in the
terminal nodes, all successors of that node will be marked as <code>TRUE</code>
as well. Conversely, if <code>forward = FALSE</code>, then all predecessors of
that node will be marked as <code>TRUE</code>.</p>

<p>For example, imagine we have a stagerunner with the following stages:</p>

<ul>
<li>import data</li>
<li>clean data

<ul>
<li>impute variable 1</li>
<li>discretize variable 2</li>
</ul></li>
<li>train model</li>
</ul>

<p>If <code>el</code>, the first argument to the <code>boolean_fill</code> function depicted on 
the right, refers to the &ldquo;impute variable 1&rdquo; stage, it will be represented
as <code>el = list(F, list(T, F), F)</code>.</p>

<ul>
<li>import data</li>
<li>clean data

<ul>
<li><strong>impute variable 1</strong></li>
<li>discretize variable 2</li>
</ul></li>
<li>train model</li>
</ul>

<p>Then calling the <code>boolean_fill</code> function depicted on the right with
<code>forward = TRUE</code> will signify we want to select the stages occuring
afterwards:</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"># The left panel will explain at a high level the code you see in this right panel.
# Scroll down to begin reading the code behind the stagerunner package.
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <ul>
<li>import data</li>
<li>clean data

<ul>
<li><strong>impute variable 1</strong></li>
<li><strong>discretize variable 2</strong></li>
</ul></li>
<li><strong>train model</strong></li>
</ul>

<p>The return value will be <code>list(F, list(T, T), T)</code>. If instead we
want the stages <em>before</em> &ldquo;impute variable 1&rdquo;, the return value
will be <code>list(T, list(T, F), F)</code>.</p>

<ul>
<li><strong>import data</strong></li>
<li><strong>clean data</strong>

<ul>
<li><strong>impute variable 1</strong></li>
<li>discretize variable 2</li>
</ul></li>
<li>train model</li>
</ul>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Fill a nested logical list with TRUEs before or after the first TRUE
#' 
#' This is a helper function to implement the \code{to} parameter
#' in the \code{run} method on a stageRunner object.
#'
#' @seealso \code{\link{stageRunner__run}}
#' @name boolean_fill
#' @param el list. A nested list of logicals with exactly one entry \code{TRUE}.
#' @param forward logical. \code{FALSE} for backwards, and \code{TRUE} for forwards.
#'   The default is \code{TRUE}.
#' @return the filled list
boolean_fill <- function(el, forward = TRUE) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We now dig into the actual code. The <code>!is.finite</code> condition on the right
works due to the behavior of <code>which</code>. If no element of the (possibly nested)
list <code>el</code> contains a <code>TRUE</code>, it will return a zero-length vector. When we 
subset to <code>[1]</code>, we get <code>NA</code>, which fails <code>is.finite</code>.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  ix <- which(vapply(el, contains_true, logical(1)))[1]
  if (!is.finite(ix)) stop("boolean_fill called but no TRUEs found")
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We could have checked that there is a <code>TRUE</code> somewhere in <code>el</code> more
elegantly, but we need the precise location, <code>ix</code>.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (isTRUE(forward)) {
    fills <- seq_len(length(el) - ix) + ix
  } else {
    fills <- seq_len(ix - 1)
  }
  el[fills] <- TRUE
  </span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If the sequence of slots before or after the index which contains a <code>TRUE</code>
(according to the value of <code>forward</code>) have been flattened to a <code>TRUE</code> value,
the only remaining <code>TRUE</code> flattening has to occur recursively in any
remaining list elements.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (!is.atomic(el[[ix]])) {
    el[[ix]] <- boolean_fill(el[[ix]], forward = forward)
  }
  el
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>compare_stage_keys.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>A stagerunner is simply a linear sequence (of usually functions)
that is packaged as a tree structure to make it easier to reference
related groups of operations.</p>

<p>Since stagerunners are intended to be run sequentially, that is,
only backward to forwards rather than the other way around, it is
important to be able to identify when it is accidentally run
in the latter way. For example, if we have three stages and
a runner is called in the wrong order with <code>runner$run(2, 1)</code>,
we expect stage 1 to execute before stage 2.</p>

<p>The point of <code>compare_stage_keys</code> is to determine whether a later
stage has been called prior to an earlier stage. If that is
the case, this function will return <code>TRUE</code>, and later in the internals
of the stagerunner object we will be able to flip the keys.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Compare two stage keys to see which one has a stage run first
#' 
#' This is a helper function to implement the \code{to} parameter
#' in the \code{run} method on a stageRunner object.
#'
#' @seealso \code{\link{stageRunner__run}}
#' @name compare_stage_keys
#' @param key1 list
#' @param key2 list
#' @return logical. Whether or not key1 runs a stage before key2.
compare_stage_keys <- function(key1, key2) {
  if (length(key1) == 0 || isTRUE(key1)) return(TRUE)
  index_of_true <- function(el) which(vapply(el, contains_true, logical(1)))[1]</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p><code>ix</code> will be a vector of the location in the list structure of <code>key1</code> and
<code>key2</code> where the first (and, if they are correctly formed, the only)
<code>TRUE</code> occurs.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  ix <- vapply(list(key1, key2), index_of_true, numeric(1))
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If no element in the first structure has a <code>TRUE</code>, the first key definitely
cannot run a stage first (since no stages have been marked for running!).</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (!is.finite(ix[1])) {
    return(FALSE)</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Otherwise, if the latter has no <code>TRUE</code>s, the first key definitely runs first.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  } else if (!is.finite(ix[2])) { return(TRUE) }

  if (ix[1] == ix[2]) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If the keys specify the exact same stage in the stagerunner, there is
a tie and we may as well return TRUE.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    if (is.atomic(key1) && is.atomic(key2)) {
      TRUE
    } else {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Otherwise, one of the two keys must be another list, so we can 
recursively determine which key runs first.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">      compare_stage_keys(key1[[ix[1]]], key2[[ix[2]]])
    }</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We now come across a special case. Imagine we have
a stagerunner as before.</p>

<ul>
<li>import data</li>
<li>clean data

<ul>
<li>impute variable 1</li>
<li><strong>remove outliers from variable 1</strong></li>
<li><strong>discretize variable 2</strong></li>
</ul></li>
<li>train model</li>
</ul>

<p>If we call <code>runner$run(&quot;clean data/2&quot;, &quot;clean data&quot;)</code> this will signify
to &ldquo;run from &#39;remove outliers from variable 1&#39; to the end of the
&#39;clean data&#39; stage&rdquo; (i.e., until &ldquo;discretize variable 2&rdquo;).</p>

<p>However, note in this case that the two keys would be represented by
<code>list(F, list(F, T, T), F)</code> and <code>list(F, T, F)</code>. If we are not
careful, the <code>compare_stage_keys</code> function will indicate that
the latter occurs before the former, the keys will be flipped,
and we will end up executing &ldquo;impute variable 1&rdquo; instead!</p>

<ul>
<li>import data</li>
<li>clean data

<ul>
<li><strong>impute variable 1</strong> (the unintended effect)</li>
<li><strong>remove outliers from variable 1</strong></li>
<li>discretize variable 2</li>
</ul></li>
<li>train model</li>
</ul>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We solve this problem by returning <code>TRUE</code> if <code>key2</code> consists purely
of <code>TRUE</code>s (i.e., if it signifies &ldquo;run until the end of this stage&rdquo;).</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  } else if (all(vapply(key2, isTRUE, logical(1)))) {
    TRUE 
  } else { </span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Finally, if the keys are directly comparable, the first key should be run
earlier if and only if the first key contains a <code>TRUE</code> earlier than the
second key.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    ix[1] < ix[2]
  }
}

</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>copy_env.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Copy one environment into another recursively.
#' 
#' @param to environment. The new environment.
#' @param from environment. The old environment.
#' @note Both \code{to} and \code{from} must be pre-existing environments
#'   or this function will error.
copy_env <- function(to, from) {
  stopifnot(is.environment(to) && is.environment(from))
  rm(list = ls(to, all.names = TRUE), envir = to)
  for (name in ls(from, all.names = TRUE)) {
    if (is.environment(from[[name]])) {
      # Copy a sub-environment in full.
      assign(name, new.env(parent = parent.env(from[[name]])), envir = to) 
      copy_env(to[[name]], from[[name]])
    } else assign(name, from[[name]], envir = to)
  }
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>is_pre_stagerunner.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>The only way to turn an object into a stagerunner is if it can be
interpreted as a hierarchical sequence of execution: run some stuff
in group A, then run some stuff in group B, and so on, with each
group potentially containing more subgroups.</p>

<p>In other words, the things which can be turned into stagerunners
are:</p>

<ul>
<li>functions</li>
<li>other stagerunners (sub-stagerunners)</li>
<li>lists composed of the above</li>
</ul>

<p>The purpose of the <code>is_pre_stagerunner</code> function is to determine
whether an object satisfies these restrictions.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Whether or not an object can be transformed into a stageRunner.
#'
#' @param x ANY. An R object for which it will be determined whether or not
#'    it admits a conversion to a stageRunner.
#' @return TRUE or FALSE according to whether the object can be transformed
#'    to a stageRunner. In general, only a function or list of functions
#'    can be turned into a stageRunner.
#' @export
#' @examples
#' stopifnot(is_pre_stagerunner(function(e) { e$x <- 1 }))
#' stopifnot(is_pre_stagerunner(list(function(e) { e$x <- 1 }, function(e) { e$y <- 2 })))
#' stopifnot(is_pre_stagerunner(
#'   list(a = function(e) { e$x <- 1 },
#'     list(b = function(e) { e$y <- 2 }, c = function(e) { e$z <- 3 }))))
#' 
#' stopifnot(!is_pre_stagerunner(NULL))
#' stopifnot(!is_pre_stagerunner(5))
#' stopifnot(!is_pre_stagerunner(iris))
is_pre_stagerunner <- function(x) {
  if (is.function(x) || is.stagerunner(x)) { return(TRUE) }
  if (!is.recursive(x) || is.environment(x)) { return(FALSE) }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Using a for loop is a tiny bit faster than an apply-family operation
because we can exit the function early.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  for (i in seq_along(x)) {
    if (!(is.function(x[[i]]) || is.stagerunner(x[[i]]) || is.null(x[[i]]) ||</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We use the base function <a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/Recall.html"><code>Recall</code></a>
for its recursive effect.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">          (is.recursive(x[[i]]) && Recall(x[[i]])))) {
      return(FALSE)
    }
  }

  TRUE
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>nested_names.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>TODO: (RK) Document literately.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Delimited names of a nested list.
#'
#' Unnamed values will use index number instead.
#'
#' @name nested_names
#' @param el list.
#' @param delim character. The delimiter with which to separate nested names.
#' @param prefix character. A prefix to every name.
#' @return a list of nested names
#' @examples
#' stagerunner:::nested_names(list(a = list(b = 1, c = list(d = 2, e = 3)), f = 4, 5))
#' # c('a/b', 'a/c/d', 'a/c/e', 'f', '3')
#' stagerunner:::nested_names(list(a = list(b = 1, c = 2), d = 2), delim = ' ', prefix = '#')
#' # c('#a b', '#a c', '#d')
nested_names <- function(el, delim = '/', prefix = '') {
  list_names <- names(el) %||% rep("", length(el))
  Reduce(c, lapply(seq_along(el), function(index) {
    name <- if (list_names[[index]] == "") as.character(index)
            else list_names[[index]]
    paste0(prefix,
      if (is.list(el[[index]]))
        paste0(name, delim, nested_names(el[[index]], delim = delim, prefix = ''))
      else name)
  }))
}</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>normalize_stage_keys.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>To determine what stages of a stagerunner to execute, we will use a nested
list format that is equivalent in structure to the runner. For example,
imagine we have a stagerunner with the following stages:</p>

<ul>
<li>import data</li>
<li>clean data

<ul>
<li>impute variable 1</li>
<li>discretize variable 2</li>
</ul></li>
<li>train model</li>
</ul>

<p>We would like to be able to execute swaths of this runner at will:
<code>runner$run(&quot;clean&quot;)</code>, <code>runner$run(&quot;clean/1&quot;, &quot;clean/2&quot;)</code> and 
<code>runner$run(2)</code> should all execute the data cleaning sub-stages.</p>

<p>The <code>normalize_stage_keys</code> function will convert human-readable
descriptions of what to execute, like <code>&quot;clean&quot;</code> or <code>2</code>, to a
nested list format that will be easier to use later during stage
execution.</p>

<p>For example, <code>&quot;clean/1&quot;</code> will be converted to
<code>list(F, list(T, F), F)</code> and mimic the structure of the stagerunner.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Normalize a reference to stage keys 
#'
#' For example, \code{list('data/one', 2)} would be converted to
#' \code{list('data', list('one')), 2)}.
#'
#' @name normalize_stage_keys
#' @param keys a list. The keys to normalize.
#' @param stages a list. The stages we're normalizing with respect to.
#' @param parent_key character. A helper for sane recursive error handling.
#'    For example, if we try to reference key \code{foo/bar}, but a recursive
#'    call to \code{normalize_stage_keys} errors when \code{bar} isn't found,
#'    we would still like the error to display the full name (\code{foo/bar}).
#' @param to an indexing parameter. If \code{keys} refers to a single stage,
#'   attempt to find all stages from that stage to this stage (or, if this one
#'   comes first, this stage to that stage). For example, if we have
#'      \code{stages = list(a = list(b = 1, c = 2), d = 3, e = list(f = 4, g = 5))}
#'   where the numbers are some functions, and we call \code{normalize_stage_keys}
#'   with \code{keys = 'a/c'} and \code{to = 'e/f'}, then we would obtain a nested
#'   list of logicals referencing \code{"a/c", "d", "e/f"}.
#' @return a list. The format is nested logicals. For example, if \code{stages} is
#'   \code{list(one = stageRunner$new(new.env(), list(subone = function(cx) 1)),
#'              two = function(cx) 1)}
#' then
#'   \code{normalize_stage_keys('one/subone')}
#' would return
#'   \code{list(one = list(subone = TRUE), two = FALSE)}.
#' @seealso stageRunner__run
#' @examples
#' \dontrun{
#'   stopifnot(identical(normalize_stage_keys("foo/bar",
#'     list(foo = list(bar = NULL, baz = NULL))),
#'     list(list(TRUE, FALSE))))
#' }
normalize_stage_keys <- function(keys, stages, to = NULL, parent_key = "") {
  if (is.null(to)) {
    normalize_stage_keys_unidirectional(keys, stages, parent_key)
  } else {
    normalize_stage_keys_bidirectional(keys, to, stages)
  }
}

normalize_stage_keys_unidirectional <- function(keys, stages, parent_key) {
  if (is.null(keys) || length(keys) == 0 || identical(keys, "")) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>By default, no key provided means to execute everything in this stage.
For single stages, that means <code>TRUE</code>. For multiple stages, a
list of <code>TRUE</code>s equal to the number of stages.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    return(if (!is.list(stages) || length(stages) == 1) TRUE
           else rep(list(TRUE), length(stages)))
  }</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Stagerunners are set up recursively, so we need to extract the <code>list</code> of
stages out of the stagerunner object. For example, </p>

<ul>
<li>import data</li>
<li>clean data

<ul>
<li>impute variable 1</li>
<li>discretize variable 2</li>
</ul></li>
</ul>

<p>actually consists of <em>two</em> stagerunners, one for the whole list and one
for the &ldquo;clean data&rdquo; stage.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (is.stagerunner(stages)) stages <- stages$stages
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>The output of <code>normalize_stage_keys</code> is a (possibly nested) list whose
terminal nodes are all logical. If <code>keys</code> is already of this format, we
are done.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (all_logical(keys)) return(keys) # Already normalized
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We performed checks for special cases, so now we call a function that
assumes all those cases have been taken care of. </p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  normalize_stage_keys_unidirectional_(keys, stages, parent_key)
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Our strategy to determine which stages to run, and thus translate <code>keys</code>
from a form like &ldquo;munge/impute variable 5&rdquo; to a nested list, will be to
start with a list of consisting entirely of <code>FALSE</code> and filling in the
sub-stages the user requested in the <code>keys</code> with <code>TRUE</code>s.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">normalize_stage_keys_unidirectional_ <- function(keys, stages, parent_key) {
  if (is.numeric(keys) && any(keys < 0)) { 
    as.list(!is.element(seq_len(stage_length(stages)), -keys))</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Negative indexing, like <code>-c(2:3)</code>, is easy: set everything <em>except</em> 
those keys to <code>TRUE</code>.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  } else {
    key_length      <- if (is.list(stages)) length(stages) else 1
    normalized_keys <- rep(list(FALSE), key_length)
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Each element of the provided keys has a chance to modify
<code>normalized_keys</code>. We achieve this using <a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/funprog.html">Reduce</a>.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    Reduce(function(normalized_keys, index) {
      normalize_stage_keys_by_index(keys, stages, parent_key, index, normalized_keys)
    }, seq_along(keys), normalized_keys)
  }
}

normalize_stage_keys_by_index <- function(keys, stages, parent_key,
                                          key_index, normalized_keys) {
  key <- keys[[key_index]]

  if (length(key) == 0) {
    stop("Invalid stage key (cannot be of length 0)")
  }

  rest_keys <- key[-1]
  key       <- key[[1]]
  
  normalize_stage_key(key = key, keys = rest_keys, stages = stages,
                      parent_key = parent_key, key_index = key_index,
                      normalized_keys = normalized_keys)
}

normalize_stage_key <- function(...) {
  UseMethod("normalize_stage_key")
}

normalize_stage_key.logical <- function(key, key_index, normalized_keys, ...) {
  normalized_keys[[key_index]] <- key
  normalized_keys
}

normalize_stage_key.numeric <- function(key, keys, stages, parent_key, 
                                        normalized_keys, ...) {
  stopifnot(length(key) == 1)
  if (key > stage_length(stages)) {
    stop(sprintf(
      "Cannot reference sub-stage %s of stage %s because it only has %d stages",
      sQuote(key), dQuote(parent_key), sQuote(stage_length(stages))
    ))
  }

  normalized_keys[[as.integer(key)]] <-
    if (length(keys) == 0) TRUE
    else normalize_stage_keys(keys, stages[[as.integer(key)]],
                              parent_key = paste0(parent_key, key, '/'))
  normalized_keys
}

normalize_stage_key.character <- function(key, keys, stages, parent_key,
                                          normalized_keys, ...) {

  # The hard part! Allow things like one/subone/subsubone/etc
  # to reference arbitrarily nested stages.
  if (length(key) == 0) stop("Stage key of length zero")
  key <- strsplit(key, '/')[[1]]

  if (is.stageRunnerNode(stages)) {
    stop("No stage with key '", paste0(parent_key, key[[1]]), "' found")
  }

  key_index <- grepl(tolower(key[[1]]), tolower(names(stages)), fixed = TRUE)

  if (is.finite(suppressWarnings(tmp <- as.numeric(key[[1]]))) &&
      tmp > 0 && tmp <= length(stages)) {
    key_index <- tmp
  } else if (length(key_index) == 0 || sum(key_index) == 0) {
    stop("No stage with key '", paste0(parent_key, key[[1]]), "' found")
  } else if (sum(key_index) > 1) {
    stop("Multiple stages with key '", paste0(parent_key, key[[1]]),
           "', found: ", paste0(parent_key, names(stages)[key_index], collapse = ', '))
  } else key_index <- which(key_index) # now an integer of length 1

  normalized_keys[[key_index]] <- special_or_lists(
    normalized_keys[[key_index]],
    normalize_stage_keys(append(paste0(key[-1], collapse = '/'), keys), 
      stages[[key_index]], parent_key = paste0(parent_key, key[[1]], '/'))
  )

  normalized_keys
}

normalize_stage_key.default <- function(...) {
  stop("Invalid stage key")
}

normalize_stage_keys_bidirectional <- function(from, to, stages) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>First, we turn our human-readable keys like &ldquo;clean/impute variable 1&rdquo;
into a more convenient list structure like <code>list(F, list(T, F, F), F)</code>.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  from <- normalize_stage_keys(from, stages)
  to   <- normalize_stage_keys(to, stages)</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Recall our helper <code>compare_stage_keys</code>, which returns <code>FALSE</code> if 
the first argument occurs before the second. In this situation, we
need to swap the keys.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (!compare_stage_keys(from, to)) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>A convenient swapping mechanism without introducing temporary variables.
In R, the <a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/list2env.html"><code>list2env</code></a> utility
can funnel named values in a list directly into an environment.
Try it yourself:</p>

<pre><code class="r">x &lt;- 1
y &lt;- 2
list2env(list(x = y, y = x), environment())
cat(x, &quot;,&quot;, y)
</code></pre>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    list2env(list(from = to, to = from), environment())
  }</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>And finally the magic trick that pulls it all together. See the more
thorough explanation below beside the <code>special_and_lists</code> helper.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  special_and_lists(
    boolean_fill(from, forward = TRUE),
    boolean_fill(to,   forward = FALSE)
  )
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Terminal stages in a stagerunner are <code>stageRunnerNode</code> objects, so we treat
those as stages of length 1.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">stage_length <- function(obj) {
  if (is.list(obj)) length(obj)
  else 1
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>show_message.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Consider our example stagerunner from before:</p>

<ul>
<li>import data</li>
<li>clean data

<ul>
<li>impute variable 1</li>
<li>discretize variable 2</li>
</ul></li>
<li>train model</li>
</ul>

<p>Our goal is to display progress when executing the stagerunner:</p>

<p><img src="http://i.imgur.com/NKN3hnk.png" alt="runner"/></p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Show a progress message when executing a stagerunner.
#'
#' @name show_message
#' @param stage_names character.
#' @param stage_index integer.
#' @param begin logical. Whether we are showing the begin or end message.
#' @param nested logical. Whether or not this is a nested stage (i.e.
#'    contains another stageRunner).
#' @param depth integer. How many tabs to space by (for nested stages).
#' @return Nothing, but print the message to standard output.
#' @examples 
#' \dontrun{
#'   show_message(c('one', 'two'), 2) # Will print "Beginning one stage..."
#' }
show_message <- function(stage_names, stage_index, begin = TRUE,
                         nested = FALSE, depth = 1) {
  stage_name <- stage_names[stage_index]
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If the stage was not named (i.e., only a function was given), we &ldquo;impute&rdquo;
the name with an ordinal: &ldquo;fifth&rdquo;, &ldquo;twelfth&rdquo;, &ldquo;21st&rdquo;, etc. (depending on
the index of the stage).</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (is.null(stage_name) || stage_name == "") {
    stage_name <- as.ordinal(stage_index)
  }

  if (begin) {
    stage_name <- crayon::green(stage_name)
  } else {
    stage_name <- crayon::blue(stage_name)
  }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We indent by <code>depth</code> double-spaces to show nested stages clearly.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  prefix     <- paste(rep("  ", depth - 1), collapse = '')</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We turn &ldquo;import data&rdquo; into &ldquo;1. import data&rdquo;.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  stage_name <- paste0(stage_index, ". ", stage_name)
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Non-terminal stages (i.e., those with more sub-stages) have a beginning
and an ending, so we show &ldquo;Beginning 2. clean data stage&rdquo; and
&ldquo;Ending 2. clean data stage&rdquo;.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (nested) {
    cat(paste0(prefix, if (begin) "Beginn" else "End", "ing ",
               stage_name, " stage...\n"))
  } else if (begin) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Whereas terminal stages (i.e., those without sub-stages) just <em>run</em>,
so we show &ldquo;Running 1. import data stage&rdquo;.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    cat(paste0(prefix, "Running ", stage_name, "...\n"))
  }
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>special_and_lists.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Imagine we want to run from &ldquo;create validation set&rdquo; to &ldquo;create derived
variable.&rdquo;</p>

<ul>
<li>import data</li>
<li><strong>create validation set</strong></li>
<li><strong>munge data</strong>

<ul>
<li><strong>impute variable 1</strong></li>
<li><strong>create derived variable</strong></li>
<li>drop some variables</li>
</ul></li>
<li>train model</li>
</ul>

<p>The syntax for this is <code>runner$run(&quot;val&quot;, &quot;munge/derived&quot;)</code> (amongst
other ways &ndash; substrings are matched to stage names by the 
<code>normalize_stage_keys</code> helper).</p>

<p>To translate this into code, stagerunner builds the following two trees:</p>

<ul>
<li><code>FALSE</code></li>
<li><strong><code>TRUE</code></strong>

<ul>
<li><strong><code>TRUE</code></strong></li>
<li><strong><code>TRUE</code></strong></li>
<li><strong><code>TRUE</code></strong></li>
</ul></li>
<li><strong><code>TRUE</code></strong></li>
</ul>

<p>and</p>

<ul>
<li><strong><code>TRUE</code></strong></li>
<li><strong><code>TRUE</code></strong>

<ul>
<li><strong><code>TRUE</code></strong></li>
<li><strong><code>TRUE</code></strong></li>
<li><code>FALSE</code></li>
</ul></li>
<li><code>FALSE</code></li>
</ul>

<p>and then <em>intersects them</em>:</p>

<ul>
<li><code>FALSE</code></li>
<li><strong><code>TRUE</code></strong>

<ul>
<li><strong><code>TRUE</code></strong></li>
<li><strong><code>TRUE</code></strong></li>
<li><code>FALSE</code></li>
</ul></li>
<li><code>FALSE</code></li>
</ul>

<p>The point of <code>special_and_lists</code> is to perform this intersection operation.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' AND two lists together with some regards for nesting
#'
#' The structure of the lists should be the same. That is,
#' as a tree, the two lists should be isomorphic. For example,
#' \code{special_and_lists(list(a = FALSE, b = list(b = TRUE, c = FALSE)),
#'                         list(a = FALSE, b = list(b = FALSE, c = TRUE)))}
#' yields
#' \code{list(a = FALSE, b = list(b = FALSE, c = TRUE))}
#' and
#' \code{special_and_lists(list(a = FALSE, b = list(b = TRUE, c = FALSE)),
#'                         list(a = list(b = FALSE, c = TRUE), b = FALSE))}
#' yields
#' \code{list(a = list(b = FALSE, c = TRUE), b = list(b = TRUE, c = FALSE))}
#'
#' Note that lists get ANDed based on *order*, not on key names (as this could
#' be ambiguous), so make sure the two lists have the same comparable key orders.
#' For example, \code{special_and_lists(list(a = TRUE, b = FALSE), list(b = FALSE, a = TRUE))}
#' would mistakenly return \code{list(a = TRUE, b = TRUE)}.
#'
#' @name special_and_lists
#' @param list1 a list.
#' @param list2 a list.
#' @seealso \code{\link{special_or_lists}}
#' @return the and'ed list.
#' @examples \dontrun{
#'   stopifnot(identical(
#'     special_and_lists(list(a = FALSE, b = list(b = TRUE, c = FALSE)),
#'                       list(a = FALSE, b = list(b = FALSE, c = TRUE))),
#'     list(a = FALSE, b = list(b = FALSE, c = TRUE))
#'  ))
#' 
#'   stopifnot(identical(
#'     special_and_lists(list(a = FALSE, b = list(b = TRUE, c = FALSE)),
#'                       list(a = list(b = FALSE, c = TRUE), b = FALSE)),
#'     list(a = list(b = FALSE, c = TRUE), b = list(b = TRUE, c = FALSE))
#'  ))
#' }
special_and_lists <- function(list1, list2) {
  if (identical(list1, FALSE) || identical(list2, FALSE)) {
    FALSE</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If one of the two lists is <code>TRUE</code>, an &ldquo;AND&rdquo; operation is simply
equivalent to choosing the other list.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  } else if (identical(list1, TRUE)) {
    list2
  } else if (identical(list2, TRUE)) {
    list1
  } else if (!(is.list(list1) && is.list(list2))) {
    stop("special_and_lists only accepts lists or atomic logicals of length 1")
  } else if (length(list1) != length(list2)) {
    stop("special_and_lists only accepts lists of the same length")
  } else {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>This function should only ever be used on lists coming from the same
hierarchy of stages, so give a warning if this is not the case.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    if (!identical(names(list1), names(list2))) {
      warning("special_and_lists matches lists by order, not name, ",
              "but the names of the two lists do not match!")
    }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We use <a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/funprog.html">Map</a>
to recursively apply the operation to the remaining elements.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    Map(special_and_lists, list1, list2)
  }
}

</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>special_or_lists.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>This function is equivalent to <code>special_and_lists</code> but instead we apply 
&ldquo;OR&rdquo; to each pair of logical values:</p>

<ul>
<li><code>FALSE</code></li>
<li><strong><code>TRUE</code></strong>

<ul>
<li><strong><code>TRUE</code></strong></li>
<li><strong><code>TRUE</code></strong></li>
<li><code>FALSE</code></li>
</ul></li>
<li><code>FALSE</code></li>
</ul>

<p>and</p>

<ul>
<li><code>FALSE</code></li>
<li><code>FALSE</code>

<ul>
<li><code>FALSE</code></li>
<li><strong><code>TRUE</code></strong></li>
<li><strong><code>TRUE</code></strong></li>
</ul></li>
<li><code>FALSE</code></li>
</ul>

<p>would become</p>

<ul>
<li><code>FALSE</code></li>
<li><strong><code>TRUE</code></strong>

<ul>
<li><strong><code>TRUE</code></strong></li>
<li><strong><code>TRUE</code></strong></li>
<li><strong><code>TRUE</code></strong></li>
</ul></li>
<li><code>FALSE</code></li>
</ul>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' OR two lists together with some regards for nesting
#'
#' The structure of the lists should be the same. That is,
#' as a tree, the two lists should be isomorphic. For example,
#' \code{special_or_lists(list(a = FALSE, b = list(b = TRUE, c = FALSE)),
#'                         list(a = FALSE, b = list(b = FALSE, c = TRUE)))}
#' yields
#' \code{list(a = FALSE, b = list(b = TRUE, c = TRUE))}
#' and
#' \code{special_or_lists(list(a = FALSE, b = list(b = TRUE, c = FALSE)),
#'                         list(a = list(b = FALSE, c = TRUE), b = FALSE))}
#' yields
#' \code{list(a = list(b = FALSE, c = TRUE), b = list(b = TRUE, c = FALSE))}
#'
#' Note that lists get ORed based on *order*, not on key names (as this could
#' be ambiguous), so make sure the two lists have the same comparable key orders.
#' For example, \code{special_or_lists(list(a = TRUE, b = FALSE), list(b = FALSE, a = TRUE))}
#' would mistakenly return \code{list(a = TRUE, b = TRUE)}.
#'
#' @name special_or_lists
#' @param list1 a list.
#' @param list2 a list.
#' @seealso \code{\link{special_and_lists}}
#' @return the or'ed list.
special_or_lists <- function(list1, list2) {
  if (identical(list1, TRUE) || identical(list2, TRUE)) {
    TRUE
  } else if (identical(list1, FALSE)) {
    list2
  } else if (identical(list2, FALSE)) {
    list1
  } else if (!(is.list(list1) && is.list(list2))) {
    stop("special_or_lists only accepts lists or atomic logicals of length 1")
  } else if (length(list1) != length(list2)) {
    stop("special_or_lists only accepts lists of the same length")
  } else {
    if (!identical(names(list1), names(list2))) {
      warning("special_or_lists matches lists by order, not name, ",
              "but the names of the two lists do not match!")
    }
     
    Map(special_or_lists, list1, list2)
  }
}

</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stage_runner-package.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' stagerunner: in-memory reproducible data preparation and modeling
#'
#' stagerunner is an attempt to define a notion of data munging that includes
#' \emph{history}. By writing your code as a stagerunner instead of a
#' collection of functions, three key advantages should become clear:
#'
#' \itemize{
#' \item Clarity will emerge in code that is intended to execute a sequence
#'   of operations that aims to produce a final result.
#' \item Reproducibility of interactive munging steps is possible without
#'   re-executing your analysis from scratch.
#' \item Modularity and extensibility becomes free of charge: methods like
#'   \code{around} and \code{transform} allow you to apply the same operation
#'   to your entire modeling procedure, simplifying progress monitoring and
#'   debugging.
#' }
#'
#' Although originally intended for clarifying the modeling process,
#' stagerunners have much more general applicability. To learn more,
#' begin with the vignettes: \code{browseVignettes(package = "stagerunner")}.
#'
#' @docType package
#' @name stagerunner
#' @import crayon R6
#' @author Robert Krzyzanowski <\url{http://syberia.io}>
#' @seealso The core function in this package: \code{\link{stagerunner}}. It
#'   defines the constructor creating stagerunner objects that allow you to
#'   wrap a complicated modeling procedure into an organized hierarchy.
#' @references Full documentation and demos: \url{http://robertzk.github.io/stagerunner/};
#'   FAQ's: \url{http://robertzk.github.io/stagerunner/faq/}
NULL
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stage_runner.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Dynamically create an accessor method for reference classes.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#accessor_method <- function(attr) {
#  fn <- eval(bquote(
#    function(`*VALUE*` = NULL)
#      if (missing(`*VALUE*`)) .(substitute(attr))
#      else .(substitute(attr)) <<- `*VALUE*`
#  ))
#  environment(fn) <- parent.frame()
#  fn
#}
#
##" Initialize a stageRunner object.
##"
##" stageRunner objects are used for executing a linear sequence of
##" actions on a context (an environment). For example, if we have an
##" environment \code{e} containing \code{x = 1, y = 2}, then using
##" \code{stages = list(function(e) e$x <- e$x + 1, function(e) e$y <- e$y - e$x)}
##" will cause \code{x = 2, y = 0} after running the stages.
##"
##" @name stageRunner__initialize
##" @param context an environment. The initial environment that is getting
##"    modified during the execution of the stages. 
##" @param .stages a list. The functions to execute on the \code{context}.
##" @param remember a logical. Whether to keep a copy of the context and its
##"    contents throughout each stage for debugging purposes--this makes it
##"    easy to go back and investigate a stage. This could be optimized by
##"    developing a package for "diffing" two environments. The default is
##"    \code{FALSE}. When set to \code{TRUE}, the return value of the
##"    \code{run} method will be a list of two environments: one of what
##"    the context looked like before the \code{run} call, and another
##"    of the aftermath.
##" @param mode character. Controls the default behavior of calling the
##"    \code{run} method for this stageRunner. The two supported options are
##"    "head" and "next". The former gives a stageRunner which always begins
##"    from the first stage if the \code{from} parameter to the \code{run}
##"    method is blank. Otherwise, it will begin from the previous unexecuted
##"    stage.  The default is "head". This argument has no effect if
##"    \code{remember = FALSE}.
#stageRunner__initialize <- function(context, .stages, remember = FALSE,
#                                    mode = getOption("stagerunner.mode") %||% 'head') {
#  # We must do our own type checking on context for compatibility with
#  # objectdiff::tracked_environment.
#  if (!is.environment(context)) {
#    stop("Please pass an ", sQuote("environment"), " as the context for ",
#         "a stageRunner")
#  }
#
#  .finished <<- FALSE # TODO: Remove this hack for printing
#  context <<- context
#
#  if (identical(remember, TRUE) && !(is.character(mode) &&
#      any((.mode <<- tolower(mode)) == c('head', 'next')))) {
#    stop("The mode parameter to the stageRunner constructor must be ",
#         "either 'head' or 'next'.")
#  }
#
#  if (length(.stages) == 0) {
#    warning("stageRunners with zero stages may cause problems.", .call = FALSE)
#  }
#
#  if (!is_pre_stagerunner(.stages)) {
#    stop("Can only turn a function or list of functions into a stageRunner", call. = FALSE)
#  }
#
#  if (is.function(.stages)) .stages <- list(.stages)
#  stages <<- .stages
#
#  # Construct recursive stagerunners out of a list of lists.
#  for (i in seq_along(stages))
#    if (is.list(stages[[i]]))
#      stages[[i]] <<- .stageRunner$new(context, stages[[i]], remember = remember)
#    else if (is.function(stages[[i]]) || is.null(stages[[i]]))
#      stages[[i]] <<- .stageRunnerNode$new(stages[[i]], context)
#
#  # Do not allow the '/' character in stage names, as it's reserved for
#  # referencing nested stages.
#  if (any(violators <- grepl('/', names(stages), fixed = TRUE))) {
#    msg <- paste0("Stage names may not have a '/' character. The following do not ",
#      "satisfy this constraint: '",
#      paste0(names(stages)[violators], collapse = "', '"), "'")
#    stop(msg)
#  }
#
#  remember <<- remember
#  if (isTRUE(remember)) {
#    # Set up parents for treeSkeleton.
#    .self$.clear_cache()
#    .self$.set_parents()
#    if (.self$with_tracked_environment()) {
#      .self$.set_prefixes()
#    } else if (length(stages) > 0) {
#      # Set the first cache environment
#      first_env <- treeSkeleton$new(stages[[1]])$first_leaf()$object
#      first_env$cached_env <- new.env(parent = parent.env(context))
#      copy_env(first_env$cached_env, context)
#    }
#  }
#}
#
##" Run the stages in a stageRunner object.
##"
##" @name stageRunner__run
##" @param from an indexing parameter. Many forms are accepted, but the
##"   easiest is the name of the stage. For example, if we have
##"   \code{stageRunner$new(context, list(stage_one = some_fn, stage_two = some_other_fn))}
##"   then using \code{run('stage_one')} will execute \code{some_fn}.
##"   Additional indexing forms are logical (which stages to execute),
##"   numeric (which stages to execute by indices), negative (all but the
##"   given stages), character (as above), and nested forms of these.
##"   The latter refers to instances of the following:
##"   \code{stageRunner$new(context, list(stage_one =
##"     stageRunner$new(context, substage_one = some_fn, substage_two = other_fn),
##"     stage_two = another_fn))}.
##"   Here, the following all execute only substage_two:
##"   \code{run(list(list(FALSE, TRUE), FALSE))},
##"   \code{run(list(list(1, 2)))},
##"   \code{run('stage_one/substage_two')},
##"   \code{run('one/two')},
##"   \code{run(list(list('one', 'two')))},
##"   \code{run(list(list('one', 2)))}
##"   Notice that regular expressions are allowed for characters.
##"   The default is \code{NULL}, which runs the whole sequences of stages.
##" @param to an indexing parameter. If \code{stage_key} refers to a single stage,
##"   attempt to run from that stage to this stage (or, if this one comes first,
##"   this stage to that stage). For example, if we have
##"      \code{stages = list(a = list(b = 1, c = 2), d = 3, e = list(f = 4, g = 5))}
##"   where the numbers are some functions, and we call \code{run} with
##"   \code{stage_key = 'a/c'} and \code{to = 'e/f'}, then we would execute
##"   stages \code{"a/c", "d", "e/f"}.
##" @param normalized logical. A convenience recursion performance helper. If
##"   \code{TRUE}, stageRunner will assume the \code{stage_key} argument is a
##" @param verbose logical. Whether or not to display pretty colored text
##"   informing about stage progress.
##"   nested list of logicals.
##" @param remember_flag logical. An internal argument used by \code{run}
##"   recursively if the \code{stageRunner} object has the \code{remember}
##"   field set to \code{TRUE}. If \code{remember_flag} is FALSE, \code{run}
##"   will not attempt to restore the context from cache (e.g., if we are
##"   executing five stages simultaneously with \code{remember = TRUE},
##"   the first stage's context should be restored from cache but none
##"   of the remaining stages should).
##" @param mode character. If \code{mode = 'head'}, then by default the
##"   \code{from} parameter will be used to execute that stage and that
##"   stage only. If \code{mode = 'next'}, then the \code{from} parameter
##"   will be used to run (by default, if \code{to} is left missing)
##"   from the last successfully executed stage to the stage given by
##"   \code{from}. If \code{from} occurs before the last successfully
##"   executed stage (say S), the stages will be run from \code{from} to S.
##" @param .depth integer. Internal parameter for keeping track of nested running level.
##" @param ... Any additional arguments to delegate to the \code{stageRunnerNode}
##"   object that will execute its own \code{run} method.
##"   (See \code{stageRunnerNode$run})
##" @return TRUE or FALSE according as running the stages specified by the
##"   \code{stage_key} succeeded or failed.  If \code{remember = TRUE},
##"   this will instead be a list of the environment before and after
##"   executing the aforementioned stages. (This allows comparing what
##"   changes were made to the \code{context} during the execution of
##"   the stageRunner.
#stageRunner__run <- function(from = NULL, to = NULL,
#                             normalized = FALSE, verbose = FALSE,
#                             remember_flag = TRUE, mode = .mode, .depth = 1, ...) {
#  if (identical(normalized, FALSE)) {
#    if (missing(from) && identical(remember, TRUE) && identical(mode, 'next')) {
#      from <- next_stage()
#      if (missing(to)) to <- TRUE
#    }
#    stage_key <- normalize_stage_keys(from, stages, to = to)
#  } else stage_key <- from
#
#  # Now that we have determined which stages to run, cycle through them all.
#  # It is up to the user to determine that context changes make sense.
#  # We also implicitly sort the stages to ensure linearity is preserved.
#  # Stagerunner enforces the linearity and directionality set in the stage definitions.
#  
#  # If we are remembering changes, recall what the environment looked like
#  # *before* we ran anything.
#  before_env <- NULL
#
#  for (stage_index in seq_along(stage_key)) {
#    nested_run <- TRUE
#    
#    # Determine how to run this stage, depending on whether it is an
#    # terminal node or nested stagerunner. We compute this first
#    # in case we run into referencing errors (e.g., the requested
#    # stage does not exist).
#    run_stage <-
#      if (identical(stage_key[[stage_index]], TRUE)) {
#        stage <- stages[[stage_index]]
#        if (is.stagerunner(stage)) { 
#          function(...) { stage$run(verbose = verbose, .depth = .depth + 1, ...) }
#        } else {
#         nested_run <- FALSE
#         # Intercept the remember_flag argument to calls to the stageRunnerNode
#         # (since it doesn't know how to use it).
#         function(..., remember_flag = TRUE) { stage$run(...) }
#        }
#      } else if (is.list(stage_key[[stage_index]])) {
#        if (!is.stagerunner(stages[[stage_index]])) {
#          stop("Invalid stage key: attempted to make a nested stage reference ",
#               "to a non-existent stage")
#        }
#
#        function(...) {
#          stages[[stage_index]]$run(stage_key[[stage_index]], normalized = TRUE,
#                                    verbose = verbose, .depth = .depth + 1, ...)
#        }
#      } else next 
#
#    display_message <- verbose && contains_true(stage_key[[stage_index]])
#    if (display_message) {
#      show_message(names(stages), stage_index, begin = TRUE,
#                   nested = nested_run, depth = .depth)
#    }
#
#    # Now handle when remember = TRUE, i.e., we have to cache the
#    # progress along each stage.
#
#    if (remember && remember_flag && is.null(before_env)) {
#      # If remember = remember_flag = TRUE and before_env has not been set
#      # this is the first stage of a $run() call, so use the cached
#      # environment.
#      if (nested_run) {
#        before_env <- run_stage(..., remember_flag = TRUE)$before
#      } else { # a leaf / terminal node
#        before_env <- .self$.before_env(stage_index)
#      }
#      
#      # If terminal node, execute the stage (if it was nested,  it's already been
#      # executed in order to recursively fetch the before_env).
#      if (!nested_run) { run_stage(...) }
#    }
#    else if (remember) { run_stage(..., remember_flag = FALSE) }
#    else { run_stage(...) }
#
#    if (remember && !nested_run) {
#      # When we're done running a stage (i.e., processing a terminal node),
#      # set the cache on the successor node to be the current context
#      # (since that node will execute starting with what's in the context now --
#      # this also ensures that running that node with a separate call to
#      # $run will not bump into a "you haven't executed this stage yet" error).
#      .self$.mark_finished(stage_index)
#    }
#
#    if (display_message) {
#      show_message(names(stages), stage_index, begin = FALSE,
#                   nested = nested_run, depth = .depth)
#    }
#  }
#
#  if (remember && remember_flag) { list(before = before_env, after = context) }
#  else { invisible(TRUE) }
#}
#
##" Wrap a function around a stageRunner's terminal nodes
##"
##" If we want to execute some behavior just before and just after executing
##" terminal nodes in a stageRunner, a solution without this method would be
##" to overlay two runners -- one before and one after. However, this is messy,
##" so this function is intended to replace this approach with just one function.
##"
##" Consider the runner
##"   \code{sr <- stageRunner$new(some_env, list(a = function(e) print('2'))}
##" If we run 
##"   \code{sr2 <- stageRunner$new(some_env, list(a = function(e) {
##"     print('1'); yield(); print('3') }))
##"    sr1$around(sr2)
##"    sr1$run()
##"  }
##" then we will see 1, 2, and 3 printed in succession. The \code{yield()}
##" keyword is used to specify when to execute the terminal node that
##" is sandwiched in the "around" runner.
##"
##" @name stageRunner__around
##" @param other_runner stageRunner. Another stageRunner from which to create
##"   an around procedure. Alternatively, we could give a function or a list
##"   of functions.
#stageRunner__around <- function(other_runner) {
#  if (is.null(other_runner)) return(.self)
#  if (!is.stagerunner(other_runner)) other_runner <- .stageRunner$new(context, other_runner)
#  stagenames <- names(other_runner$stages) %||% rep("", length(other_runner$stages))
#  lapply(seq_along(other_runner$stages), function(stage_index) {
#    name <- stagenames[stage_index]
#    this_index <- 
#      if (identical(name, "")) stage_index
#      else if (is.element(name, names(stages))) name
#      else return()
#
#    if (is.stagerunner(stages[[this_index]]) &&
#        is.stagerunner(other_runner$stages[[stage_index]])) {
#      stages[[this_index]]$around(other_runner$stages[[stage_index]])
#    } else if (is.stageRunnerNode(stages[[this_index]]) &&
#               is.stageRunnerNode(other_runner$stages[[stage_index]])) {
#      stages[[this_index]]$around(other_runner$stages[[stage_index]])
#    } else {
#      warning("Cannot apply around stageRunner because ",
#              this_index, " is not a terminal node.")
#    }
#  })
#  .self
#}
#
##" Coalescing a stageRunner object is taking another stageRunner object
##" with similar stage names and replacing the latter's cached environments
##" with the former's.
##"
##" @name stageRunner__coalesce
##" @param other_runner stageRunner. Another stageRunner from which to coalesce.
##" @note coalescing is ill-defined for stageRunner with unnamed stages,
##"    since it is impossible to tell when a stage has changed.
#stageRunner__coalesce <- function(other_runner) {
#  # TODO: Should we care about insertion of new stages causing cache wipes?
#  # For now it seems like this would just be an annoyance.
#  # stopifnot(remember)
#  if (!isTRUE(remember)) return()
#
#  if (.self$with_tracked_environment()) {
#    if (!other_runner$with_tracked_environment()) {
#      stop("Cannot coalesce stageRunners using tracked_environments with ",
#           "those using vanilla environments", call. = FALSE)
#    }
#
#    compare_head <- function(x, y) {
#      m <- seq_len(min(length(x), length(y)))
#      x[m] != y[m]
#    }
#
#    common <- sum(cumsum(compare_head(.self$stage_names(), other_runner$stage_names())) == 0)
#    # Warning: Coalescing stageRunners with tracked_environments does not
#    # duplicate the tracked_environment, so the other_runner becomes invalidated,
#    # and this is a destructive action.
#    # TODO: (RK) What if the tracked_environment given initially to the stageRunner
#    # already has some commits?
#    commits     <- package_function("objectdiff", "commits")
#    `context<-` <- function(obj, value) {
#      if (is.stagerunner(obj)) {
#        obj$context <- value
#        for (stage in obj$stages) { Recall(stage, value) }
#      } else if (is.stageRunnerNode(obj)) {
#        obj$.context <- value
#        if (is.stagerunner(obj$callable)) { Recall(obj$callable, value) }
#      }
#    }
#    .self$context  <- other_runner$context
#    for (stage in .self$stages) { context(stage) <- other_runner$context }
#    other_runner$context <- new.env(parent = emptyenv())
#    commit_count   <- length(commits(.self$context)) 
#    mismatch_count <- commit_count - (common + 1)
#    if (mismatch_count > 0) {
#      package_function("objectdiff", "force_push")(.self$context, commit_count)
#      package_function("objectdiff", "rollback")  (.self$context, mismatch_count)
#    }
#  } else {
#    if (other_runner$with_tracked_environment()) {
#      stop("Cannot coalesce stageRunners using vanilla environments with ",
#           "those using tracked_environments", call. = FALSE)
#    }
#
#    stagenames <- names(other_runner$stages) %||% character(length(other_runner$stages))
#    lapply(seq_along(other_runner$stages), function(stage_index) {
#      # TODO: Match by name *OR* index
#      if (stagenames[[stage_index]] %in% names(stages)) {
#        # If both are stageRunners, try to coalesce our sub-stages.
#        if (is.stagerunner(stages[[names(stages)[stage_index]]]) &&
#            is.stagerunner(other_runner$stages[[stage_index]])) {
#            stages[[names(stages)[stage_index]]]$coalesce(
#              other_runner$stages[[stage_index]])
#        # If both are not stageRunners, copy the cached_env if and only if
#        # the stored function and its environment are identical
#        } else if (!is.stagerunner(stages[[names(stages)[stage_index]]]) &&
#            !is.stagerunner(other_runner$stages[[stage_index]]) &&
#            !is.null(other_runner$stages[[stage_index]]$cached_env) #&&
#            #identical(deparse(stages[[names(stages)[stage_index]]]$fn),
#            #          deparse(other_runner$stages[[stage_index]]$fn)) # &&
#            # This is way too tricky and far beyond my abilities..
#            #identical(stagerunner:::as.list.environment(environment(stages[[names(stages)[stage_index]]]$fn)),
#            #          stagerunner:::as.list.environment(environment(other_runner$stages[[stage_index]]$fn)))
#            ) {
#          stages[[names(stages)[stage_index]]]$cached_env <<-
#            new.env(parent = parent.env(context))
#          if (is.environment(other_runner$stages[[stage_index]]$cached_env) &&
#              is.environment(stages[[names(stages)[stage_index]]]$cached_env)) {
#            copy_env(stages[[names(stages)[stage_index]]]$cached_env,
#                     other_runner$stages[[stage_index]]$cached_env)
#            stages[[names(stages)[stage_index]]]$executed <<- 
#              other_runner$stages[[stage_index]]$executed
#          }
#        }
#      }
#    })
#    .set_parents()
#  }
#  .self
#}
#
##" Overlaying a stageRunner object is taking another stageRunner object
##" with similar stage names and adding the latter's stages as terminal stages
##" to the former (for example, to support tests).
##"
##" @name stageRunner__overlay
##" @param other_runner stageRunner. Another stageRunner from which to overlay.
##" @param label character. The label for the overlayed stageRunner. This refers
##"    to the name the former will get wrapped with when appended to the
##"    stages of the current stageRunner. For example, if \code{label = 'test'},
##"    and a current terminal node is unnamed, it will becomes
##"    \code{list(current_node, test = other_runner_node)}.
##" @param flat logical. Whether to use the \code{stageRunner$append} method to
##"    overlay, or simply overwrite the given \code{label}. If \code{flat = TRUE},
##"    you must supply a \code{label}. The default is \code{flat = FALSE}.
#stageRunner__overlay <- function(other_runner, label = NULL, flat = FALSE) {
#  stopifnot(is.stagerunner(other_runner))
#  for (stage_index in seq_along(other_runner$stages)) {
#    name <- names(other_runner$stages)[[stage_index]]
#    index <-
#      if (identical(name, '') || identical(name, NULL)) stage_index
#      else if (name %in% names(stages)) name
#      else stop('Cannot overlay because keys do not match')
#    stages[[index]]$overlay(other_runner$stages[[stage_index]], label, flat)
#  }
#  TRUE
#}
#
##" Transform the callable's of the terminal nodes of a stageRunner.
##"
##" Every terminal node in a stageRunner is of type stageRunnerNode.
##" These each have a callable, and this method transforms those
##" callables in the way given by the first argument.
##"
##" @name stageRunner__transform
##" @param transformation function. The function which transforms one callable
##"   into another.
#stageRunner__transform <- function(transformation) {
#  for (stage_index in seq_along(stages))
#    stages[[stage_index]]$transform(transformation)
#}
#
##" Append one stageRunner to the end of another.
##"
##" @name stageRunner__append
##" @param other_runner stageRunner. Another stageRunner to append to the current one.
##" @param label character. The label for the new stages (this will be the name of the
##"   newly appended list element).
#stageRunner__append <- function(other_runner, label = NULL) {
#  stopifnot(is.stagerunner(other_runner))
#  new_stage <- structure(list(other_runner), names = label)
#  stages <<- base::append(stages, new_stage)
#  TRUE
#}
#
##" Retrieve a flattened list of canonical stage names for a stageRunner object
##"
##" For example, if we have stages
##"   \code{stages = list(a = list(b = 1, c = 2), d = 3, e = list(f = 4, g = 5))}
##" then this method would return
##"   \code{list('a/b', 'a/c', 'd', 'e/f', 'e/g')}
##"
##" @name stageRunner__stage_names
##" @return a list of canonical stage names.
##" @examples
##" f <- function() {}
##" sr <- stageRunner$new(new.env(),
##"   list(a = stageRunner$new(new.env(), list(b = f, c = f)), d = f,
##"   e = stageRunner$new(new.env(), list(f = f, g = f))))
##" sr$stage_names()
#stageRunner__stage_names <- function() {
#  nested_stages <- function(x) if (is.stagerunner(x)) nested_stages(x$stages) else x
#  nested_names(lapply(stages, nested_stages))
#}
#
##" For stageRunners with caching, find the next unexecuted stage.
##"
##" @name stageRunner__next_stage
##" @return a character stage key giving the next unexecuted stage.
##"   If all stages have been executed, this returns \code{FALSE}.
##"   If the stageRunner does not have caching enabled, this will
##"   always return the first stage key (`'1'`).
#stageRunner__next_stage <- function() {
#  for (stage_index in seq_along(stages)) {
#    is_unexecuted_terminal_node <- is.stageRunnerNode(stages[[stage_index]]) &&
#      !stages[[stage_index]]$was_executed()
#    has_unexecuted_terminal_node <- is.stagerunner(stages[[stage_index]]) &&
#      is.character(tmp <- stages[[stage_index]]$next_stage())
#
#    if (is_unexecuted_terminal_node) return(as.character(stage_index))
#    else if (has_unexecuted_terminal_node)
#      return(paste(c(stage_index, tmp), collapse = '/'))
#  }
#  FALSE
#}
#
##" Generic for printing stageRunner objects.
##" 
##" @name stageRunner__show
##" @param indent integer. Internal parameter for keeping track of nested
##"   indentation level.
#stageRunner__show <- function(indent = 0) {
#  if (missing(indent)) {
#    sum_stages <- function(x) sum(vapply(x,
#      function(x) if (is.stagerunner(x)) sum_stages(x$stages) else 1L, integer(1)))
#    caching <- if (remember) ' caching' else ''
#    cat("A", caching, " stageRunner with ", sum_stages(.self$stages), " stages:\n", sep = '')
#  }
#  stage_names <- names(stages) %||% rep("", length(stages))
#
#  # A helper function for determining if a stage has been run yet.
#  began_stage <- function(stage)
#    if (is.stagerunner(stage)) any(vapply(stage$stages, began_stage, logical(1)))
#    else if (is.stageRunnerNode(stage)) !is.null(stage$cached_env)
#    else FALSE
#
#  lapply(seq_along(stage_names), function(index) {
#    prefix <- paste0(rep('  ', (if (is.numeric(indent)) indent else 0) + 1), collapse = '')
#    marker <-
#      if (remember && began_stage(stages[[index]])) {
#        next_stage <- treeSkeleton$new(stages[[index]])$last_leaf()$successor()$object
#        if (( is.null(next_stage) && !.self$.root()$.finished) ||
#            (!is.null(next_stage) && !began_stage(next_stage))) 
#          '*' # Use a * if this is the next stage to be executed
#          # TODO: Fix the bug where we are unable to tell if the last stage
#          # finished without a .finished internal field.
#          # We need to look at and set predecessors, not successors.
#        else '+' # Other use a + for completely executed stage
#      } else '-'
#    prefix <- gsub('.$', marker, prefix)
#    stage_name <- 
#      if (is.na(stage_names[[index]]) || stage_names[[index]] == "")
#        paste0("< Unnamed (stage ", index, ") >")
#      else stage_names[[index]]
#    cat(prefix, stage_name, "\n")
#    if (is.stagerunner(stages[[index]]))
#      stages[[index]]$show(indent = indent + 1)
#  })
#
#  if (missing(indent)) { cat('Context '); print(context) }
#  NULL
#}
#
##" Whether or not the stageRunner has a key matching this input.
##"
##" @param key ANY. The potential key.
##" @return \code{TRUE} or \code{FALSE} accordingly.
#stageRunner__has_key <- function(key) {
#  has <- tryCatch(normalize_stage_keys(key, stages), error = function(.) FALSE)
#  any(c(has, recursive = TRUE))
#}
#
##" Clear all caches in this stageRunner, and recursively.
##" @name stageRunner__.clear_cache
#stageRunner__.clear_cache <- function() {
#  for (i in seq_along(stages)) {
#    if (is.stagerunner(stages[[i]])) stages[[i]]$.clear_cache()
#    else stages[[i]]$cached_env <<- NULL
#  }
#  TRUE
#}
#
##" Set all parents for this stageRunner, and recursively
##" @name stageRunner__.set_parents
#stageRunner__.set_parents <- function() {
#  for (i in seq_along(stages)) {
#    # Set convenience helper attribute "child_index" to ensure that treeSkeleton
#    # can find this stage.
#    if (is.refClass(stages[[i]])) {
#      # http://stackoverflow.com/questions/22752021/why-is-r-capricious-in-its-use-of-attributes-on-reference-class-objects
#      unlockBinding('.self', attr(stages[[i]], '.xData'))
#      attr(attr(stages[[i]], '.xData')$.self, 'child_index') <<- i
#      lockBinding('.self', attr(stages[[i]], '.xData'))
#    } else attr(stages[[i]], 'child_index') <<- i
#
#    if (!is.refClass(stages[[i]])) {
#      attr(stages[[i]], 'parent') <<- .self
#    } else {
#      # if stages[[i]] has a .set_parents method (e.g. it is a stagerunner), run that
#      if ('.set_parents' %in% ls(stages[[i]]$.refClassDef@refMethods, all.names = TRUE))
#        stages[[i]]$.set_parents()
#      stages[[i]]$parent(.self)
#    }
#  }
#  .parent <<- NULL
#}
#
##" Get an environment representing the context directly before executing a given stage.
##"
##" @note If there is a lot of data in the remembered environment, this function
##"   may be computationally expensive as it has to create a new environment
##"   with a copy of all the relevant data.
##" @param stage_index integer. The substage for which to grab the before
##"   environment.
##" @return a fresh new environment representing what would have been in
##"   the context as of right before the execution of that substage.
#stageRunner__.before_env <- function(stage_index) {
#  cannot_run_error <- function() {
#    stop("Cannot run this stage yet because some previous stages have ",
#         "not been executed.")
#  }
#
#  if (.self$with_tracked_environment()) {
#    # We are using the objectdiff package and its tracked_environment,
#    # so we have to "roll back" to a previous commit.
#    current_commit <- paste0(.self$.prefix, stage_index)
#
#    if (!current_commit %in% names(package_function("objectdiff", "commits")(context))) {
#      if (`first_commit?`(current_commit)) {
#        # TODO: (RK) Do this more robustly. This will fail if there is a 
#        # first sub-stageRunner with an empty list as its stages.
#        package_function("objectdiff", "commit")(context, current_commit)
#      } else {
#        cannot_run_error()
#      }
#    } else {
#      package_function("objectdiff", "force_push")(context, current_commit)
#    }
#
#    env <- new.env(parent = package_function("objectdiff", "parent.env.tracked_environment")(context))
#    copy_env(env, package_function("objectdiff", "environment")(context))
#    env
#  } else {
#    env <- stages[[stage_index]]$cached_env
#    if (is.null(env)) { cannot_run_error() }
#
#    # Restart execution from cache, so set context to the cached environment.
#    copy_env(context, env)
#    env
#  }
#}
#
##" Mark a given stage as being finished.
##" 
##" @param stage_index integer. The index of the substage in this stageRunner.
#stageRunner__.mark_finished <- function(stage_index) {
#  node <- treeSkeleton$new(stages[[stage_index]])$successor()
#
#  if (!is.null(node)) { # Prepare a cache for the future!
#    if (.self$with_tracked_environment()) {
#      # We assume the head for the tracked_environment is set correctly.
#      package_function("objectdiff", "commit")(context, node$object$index())
#    } else {
#      node$object$cached_env <- new.env(parent = parent.env(context))
#      copy_env(node$object$cached_env, context)
#    }
#  } else {
#    # TODO: Remove this hack used for printing
#    root <- .self$.root()
#    root$.finished <- TRUE
#  }
#}
#
##" Determine the root of the stageRunner.
##"
##" @name stageRunner__.root
##" @return the root of the stageRunner
#stageRunner__.root <- function() {
#  treeSkeleton$new(.self)$root()$object
#}
#
##" Stage runner is a reference class for parametrizing and executing
##" a linear sequence of actions.
##" 
##" @name .stageRunner
##" @export
#NULL
#
#.stageRunner <- setRefClass('stageRunner',
#  fields = list(context = 'ANY', stages = 'list', remember = 'logical',
#                .mode = 'character', .parent = 'ANY', .finished = 'logical',
#                .prefix = 'character'),
#  methods = list(
#    initialize   = stageRunner__initialize,
#    run          = stageRunner__run,
#    around       = stageRunner__around,
#    coalesce     = stageRunner__coalesce,
#    overlay      = stageRunner__overlay,
#    transform    = stageRunner__transform,
#    append       = stageRunner__append,
#    stage_names  = stageRunner__stage_names,
#    parent       = accessor_method(.parent),
#    children     = function() { stages },
#    next_stage   = stageRunner__next_stage,
#    show         = stageRunner__show,
#    has_key      = stageRunner__has_key,
#    mode         = accessor_method(.mode),
#    .set_parents = stageRunner__.set_parents,
#    .clear_cache = stageRunner__.clear_cache,
#    .root        = stageRunner__.root,
#
#    # objectdiff intertwined functionality
#    .set_prefixes  = stageRunner__.set_prefixes,
#    .before_env    = stageRunner__.before_env,
#    .mark_finished = stageRunner__.mark_finished,
#    with_tracked_environment = function() { is(context, 'tracked_environment') }
#  )
#)
#
# 
# # Check whether an R object is a stageRunner object
# #
# # @export
# # @param obj any object.
# # @return \code{TRUE} if the object is of class
# #    \code{stageRunner}, \code{FALSE} otherwise.
# is.stagerunner <- function(obj) inherits(obj, 'stageRunner')
# # @export
# is.stageRunner <- is.stagerunner

#" Stagerunner nodes are environment wrappers around individual stages
#" (i.e. functions) in order to track meta-data (e.g., for caching).
#" 
#" @param fn function. This will be wrapped in an environment.
#" @param parent_obj stageRunner. The enclosing stageRunner object.
#" @param parent_env environment. The parent environment of the created
#"   \code{stageRunnerNode} object. The default is the calling
#"   environment (i.e., \code{parent.frame()}).
#" @return an environment with some additional attributes for
#"   navigating in a tree-like structure.
#" @name stageRunnerNode
#" @docType class
#.stageRunnerNode <- setRefClass('stageRunnerNode',
#  fields = list(callable = 'ANY',
#                cached_env = 'ANY',
#                .context = 'ANY',
#                .parent = 'ANY',
#                executed = 'logical'),
#  methods = list(
#    initialize = function(.callable, .context = NULL) {
#      stopifnot(is_any(.callable, c('stageRunner', 'function', 'NULL')))
#      callable <<- .callable; .context <<- .context; executed <<- FALSE
#    },
#    run = function(..., .cached_env = NULL, .callable = callable) {
#      # TODO: Clean this up by using environment injection utility fn
#      correct_cache <- .cached_env %||% cached_env
#      if (is.null(.callable)) FALSE
#      else if (is.stagerunner(.callable))
#        .callable$run(..., .cached_env = correct_cache)
#      else {
#        tmp <- new.env(parent = environment(.callable))
#        environment(.callable) <- tmp
#        environment(.callable)$cached_env <- correct_cache
#        on.exit(environment(.callable) <- parent.env(environment(.callable)))
#        .callable(.context, ...)
#      }
#      executed <<- TRUE
#    }, 
#
#    # This function goes hand in hand with stageRunner$around
#    around = function(other_node) {
#      if (is.stageRunnerNode(other_node)) other_node <- other_node$callable
#      if (is.null(other_node)) return(FALSE)
#      if (!is.function(other_node)) {
#        warning("Cannot apply stageRunner$around in a terminal ",
#                "node except with a function. Instead, I got a ",
#                class(other_node)[1])
#        return(FALSE)
#      }
#
#      new_callable <- other_node
#      # Inject yield() keyword
#      yield_env <- new.env(parent = environment(new_callable))
#      yield_env$.parent_context <- .self
#      yield_env$yield <- function() {
#        # ... lives up two frames, but the run function lives up 1,
#        # so we have to do something ugly
#        run <- eval.parent(quote(.parent_context$run))
#        args <- append(eval.parent(quote(list(...)), n = 2),
#          list(.callable = callable))
#        do.call(run, args, envir = parent.frame())
#      }
#      environment(yield_env$yield) <- new.env(parent = baseenv())
#      environment(yield_env$yield)$callable <- callable
#
#      environment(new_callable) <- yield_env
#      callable <<- new_callable
#      TRUE
#    },
#
#    overlay = function(other_node, label = NULL, flat = FALSE) {
#      if (is.stageRunnerNode(other_node)) other_node <- other_node$callable
#      if (is.null(other_node)) return(FALSE)
#      if (!is.stagerunner(other_node)) 
#        other_node <- .stageRunner$new(.context, other_node)
#
#      # Coerce the current callable object to a stageRunner so that
#      # we can append the other_node's stageRunner.
#      if (!is.stagerunner(callable)) 
#        callable <<- .stageRunner$new(.context, callable)
#
#      # TODO: Fancier merging here
#      if (isTRUE(flat)) {
#        if (!is.character(label)) stop("flat coalescing needs a label")
#        callable$stages[[label]] <<- other_node
#      } else callable$append(other_node, label)
#    },
#    transform = function(transformation) {
#      if (is.stagerunner(callable)) callable$transform(transformation)
#      else callable <<- transformation(callable)
#    },
#    was_executed = function() { executed },
#    parent   = accessor_method(.parent),
#    children = function() list(),
#    show     = function() { cat("A stageRunner node containing: \n"); print(callable) },
#
#    # Functions which intertwine with the objectdiff package
#    index    = function() {
#      ix <- which(vapply(.self$.parent$stages,
#        function(x) identical(.self, x$.self), logical(1)))
#      paste0(.self$.parent$.prefix, ix)
#    }
#  )
#)
#
# is.stageRunnerNode <- function(obj) inherits(obj, 'stageRunnerNode')
#</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner_R6.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' @include stagerunner-initialize.R stagerunner-run.R stagerunner-around.R
#'   stagerunner-coalesce.R stagerunner-overlay.R stagerunner-transform.R
#'   stagerunner-append.R stagerunner-stage_names.R stagerunner-next_stage.R
#'   stagerunner-show.R stagerunner-has_key.R stagerunner-internal.R
#'   stageRunnerNode.R
NULL

stageRunner_ <- R6::R6Class('stageRunner',
  active = list(context = function() self$.context),                            
  public = list(
    .context = NULL,
    stages = list(),
    remember = FALSE,
    .mode = "head",
    .parent = NULL,
    .finished = FALSE,
    .prefix = "",
    initialize   = stagerunner_initialize,
    run          = run,
    around       = stageRunner_around,
    coalesce     = stageRunner_coalesce,
    overlay      = stageRunner_overlay,
    transform    = stageRunner_transform,
    append       = stageRunner_append,
    stage_names  = stageRunner_stage_names,
    parent       = function() { self$.parent },
    children     = function() { self$stages },
    next_stage   = stageRunner_next_stage,
    show         = stageRunner_show,
    has_key      = stageRunner_has_key,
    mode         = function() { self$mode },
    .set_parents = stageRunner_.set_parents,
    .clear_cache = stageRunner_.clear_cache,
    .root        = stageRunner_.root,

    # objectdiff intertwined functionality
    .set_prefixes  = stageRunner_.set_prefixes,
    .before_env    = stageRunner_.before_env,
    .mark_finished = stageRunner_.mark_finished,
    with_tracked_environment = function() {
      out <- is(self$context, 'tracked_environment')
      if (out) { requireNamespace("objectdiff", quietly = TRUE) }
      out
    }
  )
)

#' @export
stageRunner <- structure(
  function(...) { stageRunner_$new(...) },
  class = "stageRunner_"
)

#' @export
stagerunner <- stageRunner

#' @export
`$.stageRunner_` <- function(...) {
  stopifnot(identical(..2, "new"))
  ..1
}

#' Check whether an R object is a stageRunner object
#'
#' @export
#' @param obj any object.
#' @return \code{TRUE} if the object is of class
#'    \code{stageRunner}, \code{FALSE} otherwise.
is.stagerunner <- function(obj) inherits(obj, 'stageRunner')
#' @rdname is.stagerunner
#' @export
is.stageRunner <- is.stagerunner
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-append.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Append one stageRunner to the end of another.
#'
#' @name stageRunner_append
#' @param other_runner stageRunner. Another stageRunner to append to the current one.
#' @param label character. The label for the new stages (this will be the name of the
#'   newly appended list element).
stageRunner_append <- function(other_runner, label = NULL) {
  stopifnot(is.stagerunner(other_runner))
  new_stage <- structure(list(other_runner), names = label)
  self$stages <- base::append(self$stages, new_stage)
  TRUE
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-around.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>The <code>around</code> method on a stagerunner is used as sort of <a href="http://stackoverflow.com/questions/6854658/explain-the-setup-and-teardown-methods-used-in-test-cases">setup and teardown</a>
hooks on arbitrary stages.</p>

<p>For example, imagine we have a stagerunner that looks like the following.</p>

<ul>
<li>import data</li>
<li>clean data

<ul>
<li>impute variable 1</li>
<li>discretize variable 2</li>
</ul></li>
</ul>

<p>Imagine we want to write test functions that ensure the correct behavior
is happening during the data cleaning. We can write a stagerunner with
an identical tree structure that performs additional testing to ensure
our work is correct:</p>

<pre><code class="r">new_runner &lt;- stageRunner$new(new.env(), list(
  &quot;import data&quot; = function(e) { yield(); stopifnot(!is.null(e$data)) },
  &quot;clean data&quot;  = list(
    &quot;impute variable 1&quot; = function(e) {
      yield()
      stopifnot(!any(is.na(e$data$variable1)))
    }, &quot;discretize variable 2&quot; = function(e) {
      yield()
      stopifnot(is.factor(e$data$variable2))
   })
))
</code></pre>

<p>The keyword <code>yield</code> is injected into a stagerunner that is used with the
<code>around</code> method, and means &ldquo;execute the stage of the stagerunner that is
being wrapped that would normally occur at this point.&rdquo; Code before
and after the <code>yield</code> keyword can be used to perform additional assertions
about what happened during the execution of the stage.</p>

<pre><code class="r">runner$around(new_runner)
runner$run()
</code></pre>

<p>If any of the above assertions fail, we will now get an error.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Wrap a function around a stageRunner's terminal nodes
#'
#' If we want to execute some behavior just before and just after executing
#' terminal nodes in a stageRunner, a solution without this method would be
#' to overlay two runners -- one before and one after. However, this is messy,
#' so this function is intended to replace this approach with just one function.
#'
#' Consider the runner
#'   \code{sr <- stageRunner$new(some_env, list(a = function(e) print('2'))}
#' If we run 
#'   \code{sr2 <- stageRunner$new(some_env, list(a = function(e) {
#'     print('1'); yield(); print('3') }))
#'    sr1$around(sr2)
#'    sr1$run()
#'  }
#' then we will see 1, 2, and 3 printed in succession. The \code{yield()}
#' keyword is used to specify when to execute the terminal node that
#' is sandwiched in the "around" runner.
#'
#' @name stageRunner_around
#' @param other_runner stageRunner. Another stageRunner from which to create
#'   an around procedure. Alternatively, we could give a function or a list
#'   of functions.
stageRunner_around <- function(other_runner) {
  if (is.null(other_runner)) return(self)
  if (!is.stagerunner(other_runner)) {
    other_runner <- stageRunner$new(self$.context, other_runner)
  }

  stagenames <- names(other_runner$stages) %||% rep("", length(other_runner$stages))
  lapply(seq_along(other_runner$stages), function(stage_index) {
    name <- stagenames[stage_index]
    this_index <- 
      if (identical(name, "")) stage_index
      else if (is.element(name, names(self$stages))) name
      else return()

    if (is.stagerunner(self$stages[[this_index]]) &&
        is.stagerunner(other_runner$stages[[stage_index]])) {
      self$stages[[this_index]]$around(other_runner$stages[[stage_index]])
    } else if (is.stageRunnerNode(self$stages[[this_index]]) &&
               is.stageRunnerNode(other_runner$stages[[stage_index]])) {
      self$stages[[this_index]]$around(other_runner$stages[[stage_index]])
    } else {
      warning("Cannot apply around stageRunner because ",
              this_index, " is not a terminal node.")
    }
  })
  self
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-coalesce.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Coalescing a stageRunner object is taking another stageRunner object
#' with similar stage names and replacing the latter's cached environments
#' with the former's.
#'
#' @name stageRunner_coalesce
#' @param other_runner stageRunner. Another stageRunner from which to coalesce.
#' @note coalescing is ill-defined for stageRunner with unnamed stages,
#'    since it is impossible to tell when a stage has changed.
stageRunner_coalesce <- function(other_runner) {
  # TODO: Should we care about insertion of new stages causing cache wipes?
  # For now it seems like this would just be an annoyance.
  # stopifnot(remember)
  if (!isTRUE(self$remember)) return()

  if (self$with_tracked_environment()) {
    if (!other_runner$with_tracked_environment()) {
      stop("Cannot coalesce stageRunners using tracked_environments with ",
           "those using vanilla environments", call. = FALSE)
    }

    compare_head <- function(x, y) {
      m <- seq_len(min(length(x), length(y)))
      x[m] != y[m]
    }

    common <- sum(cumsum(compare_head(self$stage_names(), other_runner$stage_names())) == 0)
    # Warning: Coalescing stageRunners with tracked_environments does not
    # duplicate the tracked_environment, so the other_runner becomes invalidated,
    # and this is a destructive action.
    # TODO: (RK) What if the tracked_environment given initially to the stageRunner
    # already has some commits?
    commits     <- package_function("objectdiff", "commits")
    `.context<-` <- function(obj, value) {
      if (is.stagerunner(obj)) {
        obj$.context <- value
        for (stage in obj$stages) { Recall(stage, value) }
      } else if (is.stageRunnerNode(obj)) {
        obj$.context <- value
        if (is.stagerunner(obj$callable)) { Recall(obj$callable, value) }
      }
    }
    self$.context  <- other_runner$.context
    for (stage in self$stages) { .context(stage) <- other_runner$.context }
    other_runner$.context <- new.env(parent = emptyenv())
    commit_count   <- length(commits(self$.context)) 
    mismatch_count <- commit_count - (common + 1)
    if (mismatch_count > 0) {
      package_function("objectdiff", "force_push")(self$.context, commit_count)
      package_function("objectdiff", "rollback")  (self$.context, mismatch_count)
    }
  } else {
    if (other_runner$with_tracked_environment()) {
      stop("Cannot coalesce stageRunners using vanilla environments with ",
           "those using tracked_environments", call. = FALSE)
    }

    stagenames <- names(other_runner$stages) %||% character(length(other_runner$stages))
    lapply(seq_along(other_runner$stages), function(stage_index) {
      # TODO: Match by name *OR* index
      if (stagenames[[stage_index]] %in% names(self$stages)) {
        # If both are stageRunners, try to coalesce our sub-stages.
        if (is.stagerunner(self$stages[[names(self$stages)[stage_index]]]) &&
            is.stagerunner(other_runner$stages[[stage_index]])) {
            self$stages[[names(self$stages)[stage_index]]]$coalesce(
              other_runner$stages[[stage_index]])
        # If both are not stageRunners, copy the cached_env if and only if
        # the stored function and its environment are identical
        } else if (!is.stagerunner(self$stages[[names(self$stages)[stage_index]]]) &&
            !is.stagerunner(other_runner$stages[[stage_index]]) &&
            !is.null(other_runner$stages[[stage_index]]$.cached_env) #&&
            #identical(deparse(stages[[names(stages)[stage_index]]]$fn),
            #          deparse(other_runner$stages[[stage_index]]$fn)) # &&
            # This is way too tricky and far beyond my abilities..
            #identical(stagerunner:::as.list.environment(environment(stages[[names(stages)[stage_index]]]$fn)),
            #          stagerunner:::as.list.environment(environment(other_runner$stages[[stage_index]]$fn)))
            ) {
          self$stages[[names(self$stages)[stage_index]]]$.cached_env <-
            new.env(parent = parent.env(self$.context))
          if (is.environment(other_runner$stages[[stage_index]]$.cached_env) &&
              is.environment(self$stages[[names(self$stages)[stage_index]]]$.cached_env)) {
            copy_env(self$stages[[names(self$stages)[stage_index]]]$.cached_env,
                     other_runner$stages[[stage_index]]$.cached_env)
            self$stages[[names(self$stages)[stage_index]]]$executed <- 
              other_runner$stages[[stage_index]]$executed
          }
        }
      }
    })
    self$.set_parents()
  }
  self
}

</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-has_key.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Whether or not the stageRunner has a key matching this input.
#'
#' @param key ANY. The potential key.
#' @return \code{TRUE} or \code{FALSE} accordingly.
stageRunner_has_key <- function(key) {
  has <- tryCatch(normalize_stage_keys(key, self$stages), error = function(.) FALSE)
  any(c(has, recursive = TRUE))
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-initialize.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Initialize a stageRunner object.
#'
#' stageRunner objects are used for executing a linear sequence of
#' actions on a context (an environment). For example, if we have an
#' environment \code{e} containing \code{x = 1, y = 2}, then using
#' \code{stages = list(function(e) e$x <- e$x + 1, function(e) e$y <- e$y - e$x)}
#' will cause \code{x = 2, y = 0} after running the stages.
#'
#' @name stageRunner_initialize
#' @param context environment. The initial environment that is getting
#'    modified during the execution of the stages. 
#' @param stages list. The functions to execute on the \code{context}.
#' @param remember logical. Whether to keep a copy of the context and its
#'    contents throughout each stage for debugging purposes--this makes it
#'    easy to go back and investigate a stage.
#'    
#'    The default is \code{FALSE}. When set to \code{TRUE}, the return value
#'    of the \code{run} method will be a list of two environments: one of what
#'    the context looked like before the \code{run} call, and another
#'    of the aftermath.</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>When a stagerunner object is initialized, it needs to convert a
pre-stagerunner, like</p>

<pre><code class="r">list(first = some_function, second = list(
  sub1 = another_function, sub2 = a_third_function
)
</code></pre>

<p>into a stagerunner object. This class constructor will turn the above
into a hierarchy of stagerunners to make it easier to recursively
re-use functionality.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' @param mode character. Controls the default behavior of calling the
#'    \code{run} method for this stageRunner. The two supported options are
#'    "head" and "next". The former gives a stageRunner which always begins
#'    from the first stage if the \code{from} parameter to the \code{run}
#'    method is blank. Otherwise, it will begin from the previous unexecuted
#'    stage. The default is "head". This argument has no effect if
#'    \code{remember = FALSE}.
stagerunner_initialize <- function(context, stages, remember = FALSE,
                                   mode = getOption("stagerunner.mode") %||% "head") {
  </span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>As a convenient shortcut, if a stagerunner is initialized without a second
argument but with a first argument that can be turned into stages, we 
create a new environment for the context.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (missing(stages) && !missing(context) && is_pre_stagerunner(context)) {
    stages  <- context</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>The only parent environment that makes sense is the calling environment.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    context <- new.env(parent = parent.frame())
  }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>The <code>enforce_type</code> helper in utils.R will print a nice and colorful error
message if we have initialized our stagerunner with the wrong argument
types.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  enforce_type(context,  "environment", "stagerunner", "context")
  enforce_type(remember, "logical",     "stagerunner", "remember")
  enforce_type(mode,     "character",   "stagerunner", "mode")
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p><a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/match.arg.html"><code>match.arg</code></a>
is a convenient base R helper that will error unless one of a given set of
options is chosen.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  match.arg(mode, c("head", "next"))

  stopifnot(length(remember) == 1)

  self$.parent   <- NULL
  # The .finished flag is used for certain features when printing a stagerunner.
  self$.finished <- FALSE 
  self$.context  <- context
  self$.mode     <- tolower(mode)
  self$remember  <- remember
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>A stagerunner will recursively be represented using more stagerunners.
This way, we can re-use methods defined on a stagerunner on local 
subsections.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  self$stages    <- initialize_stages(stages, context, remember)
  </span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We wrap up with some messy initialization in case our stagerunner
intends to remember progress.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (isTRUE(self$remember)) {
    initialize_remembrance(self)
  }
}

initialize_stages <- function(stages, context, remember) {
  if (length(stages) == 0) {
    warning("stagerunners with zero stages may cause problems.")
  }

  if (!is_pre_stagerunner(stages)) {
    stop("Can only turn a function or list of functions into a stagerunner.")
  }

  if (is.function(stages)) {
    stages <- list(stages)
  }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>A loop is slightly faster than an <code>lapply</code> here.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  for (i in seq_along(stages)) {
    if (is.list(stages[[i]])) {
      stages[[i]] <- stagerunner(context, stages[[i]], remember = remember)
    } else if (is.function(stages[[i]]) || is.null(stages[[i]])) {
      stages[[i]] <- stageRunnerNode(stages[[i]], context)
    }
  }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We will be using the <code>/</code> character in a special way for running 
stages. For example, if we had a runner such as </p>

<ul>
<li>import data</li>
<li>clean data

<ul>
<li>impute variable 1</li>
<li>discretize variable 2</li>
</ul></li>
</ul>

<p>we would run the first substage using <code>runner$run(&quot;clean data/impute variable 1&quot;)</code>.
To avoid complications, we prevent the use of slashes in the stage names.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  prevent_stage_name_violators(stages)

  stages
}

prevent_stage_name_violators <- function(stages) {
  if (any(violators <- grepl("/", names(stages), fixed = TRUE))) {
    stop(paste0("Stage names may not have a '/' character. The following do not ",
      "satisfy this constraint: '",
      paste0(names(stages)[violators], collapse = "', '"), "'"))
  }
}

initialize_remembrance <- function(stagerunner) {
  stagerunner$.clear_cache()</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We set up some meta-data that will be used to track the 
changes occuring in the stagerunner. See the <code>treeSkeleton</code> class
later for more details.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  stagerunner$.set_parents()
  if (stagerunner$with_tracked_environment()) {
    stagerunner$.set_prefixes()
  } else if (length(stagerunner$stages) > 0) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>The very first stage should remember what the context looked like
upon initialization. After all, if a user messed with the context
and later re-runs the stagerunner from scratch, it should remember
what the context looked like <em>at the time of initialization</em>.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    first_env <- treeSkeleton$new(stagerunner$stages[[1]])$first_leaf()$object
    first_env$.cached_env <- new.env(parent = parent.env(stagerunner$.context))
    copy_env(first_env$.cached_env, stagerunner$.context)
  }
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-internal.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Clear all caches in this stageRunner, and recursively.
#' @name stageRunner_.clear_cache
stageRunner_.clear_cache <- function() {
  for (i in seq_along(self$stages)) {
    if (is.stagerunner(self$stages[[i]])) self$stages[[i]]$.clear_cache()
    else self$stages[[i]]$.cached_env <- NULL
  }
  TRUE
}

#' Set all parents for this stageRunner, and recursively
#' @name stageRunner_.set_parents
stageRunner_.set_parents <- function() {
  for (i in seq_along(self$stages)) {
    # Set convenience helper attribute "child_index" to ensure that treeSkeleton
    # can find this stage.
    attr(self$stages[[i]], 'child_index') <<- i
    attr(self$stages[[i]], 'parent') <<- self
  }
  self$.parent <- NULL
}

#' Get an environment representing the context directly before executing a given stage.
#'
#' @note If there is a lot of data in the remembered environment, this function
#'   may be computationally expensive as it has to create a new environment
#'   with a copy of all the relevant data.
#' @param stage_index integer. The substage for which to grab the before
#'   environment.
#' @return a fresh new environment representing what would have been in
#'   the context as of right before the execution of that substage.
stageRunner_.before_env <- function(stage_index) {
  cannot_run_error <- function() {
    stop("Cannot run this stage yet because some previous stages have ",
         "not been executed.")
  }

  if (self$with_tracked_environment()) {
    # We are using the objectdiff package and its tracked_environment,
    # so we have to "roll back" to a previous commit.
    current_commit <- paste0(self$.prefix, stage_index)

    if (!current_commit %in% names(package_function("objectdiff", "commits")(self$.context))) {
      if (`first_commit?`(current_commit)) {
        # TODO: (RK) Do this more robustly. This will fail if there is a 
        # first sub-stageRunner with an empty list as its stages.
        package_function("objectdiff", "commit")(self$.context, current_commit)
      } else {
        cannot_run_error()
      }
    } else {
      package_function("objectdiff", "force_push")(self$.context, current_commit)
    }

    env <- new.env(parent = package_function("objectdiff", "parent.env.tracked_environment")(self$.context))
    copy_env(env, package_function("objectdiff", "environment")(self$.context))
    env
  } else {
    env <- self$stages[[stage_index]]$.cached_env
    if (is.null(env)) { cannot_run_error() }

    # Restart execution from cache, so set context to the cached environment.
    copy_env(self$.context, env)
    env
  }
}

#' Mark a given stage as being finished.
#' 
#' @param stage_index integer. The index of the substage in this stageRunner.
stageRunner_.mark_finished <- function(stage_index) {
  node <- treeSkeleton$new(self$stages[[stage_index]])$successor()

  if (!is.null(node)) { # Prepare a cache for the future!
    if (self$with_tracked_environment()) {
      # We assume the head for the tracked_environment is set correctly.
      package_function("objectdiff", "commit")(self$.context, node$object$index())
    } else {
      node$object$.cached_env <- new.env(parent = parent.env(self$.context))
      copy_env(node$object$.cached_env, self$.context)
    }
  } else {
    # TODO: Remove this hack used for printing
    root <- self$.root()
    root$.finished <- TRUE
  }
}

#' Determine the root of the stageRunner.
#'
#' @name stageRunner_.root
#' @return the root of the stageRunner
stageRunner_.root <- function() {
  treeSkeleton$new(self)$root()$object
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-next_stage.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' For stageRunners with caching, find the next unexecuted stage.
#'
#' @name stageRunner_next_stage
#' @return a character stage key giving the next unexecuted stage.
#'   If all stages have been executed, this returns \code{FALSE}.
#'   If the stageRunner does not have caching enabled, this will
#'   always return the first stage key (`'1'`).
stageRunner_next_stage <- function() {
  for (stage_index in seq_along(self$stages)) {
    is_unexecuted_terminal_node <- is.stageRunnerNode(self$stages[[stage_index]]) &&
      !self$stages[[stage_index]]$was_executed()
    has_unexecuted_terminal_node <- is.stagerunner(self$stages[[stage_index]]) &&
      is.character(tmp <- self$stages[[stage_index]]$next_stage())

    if (is_unexecuted_terminal_node) return(as.character(stage_index))
    else if (has_unexecuted_terminal_node)
      return(paste(c(stage_index, tmp), collapse = '/'))
  }
  FALSE
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-objectdiff.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"># Some features of stageRunner, specifically its interaction with the
# objectdiff package, require some additional setup. We attempt to record
# all of these dependencies in this file.

#' Set all prefixes for child stageRunners.
#'
#' When a stageRunner is used in conjunction with an
#' \code{objectdiff::tracked_environment}, we need to remember
#' the full nested tree structure. This function sets up the
#' \code{prefix} member of each sub-stageRunner recursively to enable
#' correct remembering functionality.
#'
#' @param prefix character. The prefix to assign to this stageRunner.
#' @name stageRunner_.set_prefixes
stageRunner_.set_prefixes <- function(prefix = '') {
  self$.prefix <- prefix
  for (i in seq_along(self$stages)) {
    if (is.stageRunner(self$stages[[i]])) {
      self$stages[[i]]$.set_prefixes(paste0(prefix, i, '/'))
    }
  }
}

`first_commit?` <- function(commit) {
  all(strsplit(commit, "/", fixed = TRUE)[[1]] == '1')
}

</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-overlay.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Overlaying a stageRunner object is taking another stageRunner object
#' with similar stage names and adding the latter's stages as terminal stages
#' to the former (for example, to support tests).
#'
#' @name stageRunner_overlay
#' @param other_runner stageRunner. Another stageRunner from which to overlay.
#' @param label character. The label for the overlayed stageRunner. This refers
#'    to the name the former will get wrapped with when appended to the
#'    stages of the current stageRunner. For example, if \code{label = 'test'},
#'    and a current terminal node is unnamed, it will becomes
#'    \code{list(current_node, test = other_runner_node)}.
#' @param flat logical. Whether to use the \code{stageRunner$append} method to
#'    overlay, or simply overwrite the given \code{label}. If \code{flat = TRUE},
#'    you must supply a \code{label}. The default is \code{flat = FALSE}.
stageRunner_overlay <- function(other_runner, label = NULL, flat = FALSE) {
  stopifnot(is.stagerunner(other_runner))
  for (stage_index in seq_along(other_runner$stages)) {
    name <- names(other_runner$stages)[[stage_index]]
    index <-
      if (identical(name, '') || identical(name, NULL)) stage_index
      else if (name %in% names(self$stages)) name
      else stop('Cannot overlay because keys do not match')
    self$stages[[index]]$overlay(other_runner$stages[[stage_index]], label, flat)
  }
  TRUE
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-run.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>The heart of a stagerunner object is its <code>run</code> method, depicted on the
right. A stagerunner consists of two things:</p>

<ul>
<li><p><strong>a context</strong>: This is an <a href="http://adv-r.had.co.nz/Environments.html">environment</a> object
that allows the user to persistently store information between stages.
The usual way to build a data pipeline is to provide functions with
various inputs and hook them up to functions with various outputs.</p>

<p>This is nice because it is clear what the inputs and outputs will be.
However, the disadvantage is that hooking up all the functions can
become pretty messy.</p>

<p>In this approach, we let the user set their own
conventions for what to place in the context. The advantage is that
<em>all stages have the same form</em>, a function taking one argument (the 
context), and so they become easy to manipulate.</p></li>
<li><p><strong>stages</strong>: A list of functions or, recursively, other stagerunners. Each function
should take precisely one argument: the <em>context</em> described above.
If you have some familiarity with pure mathematics, you will know the
<a href="http://en.wikipedia.org/wiki/Group_action">original inspiration</a> for stagerunners:
a stagerunner is a sequence of actions on an environment.</p></li>
</ul>

<p><em>Running</em> a portion of a stagerunner means to execute some of its stages on 
its context. For example, suppose we start with an empty environment
<code>context = new.env()</code> and the following stages:</p>

<pre><code class="r">context &lt;- new.env()
runner  &lt;- stagerunner(context, list(
 &quot;Set x&quot;    = function(e) { e$x &lt;- 1 },
 &quot;Double x&quot; = function(e) { e$x &lt;- 2 * e$x }
))
</code></pre>

<p>If we write <code>runner$run(&quot;Set x&quot;)</code>, then <code>context$x</code> will become <code>1</code>.
If we write <code>runner$run(2)</code> (a syntactical shortcut), then <code>context$x</code>
becomes <code>2</code>. If we write <code>runner$run(2)</code> again, it will become <code>4</code>.</p>

<p>The real advantage of this approach becomes clear when we enable the <code>remember</code>
flag:</p>

<pre><code class="r">context &lt;- new.env()
runner  &lt;- stagerunner(remember = TRUE, context, list(
  &quot;Import data&quot;               = function(e) e$data &lt;- iris,
  &quot;Create dependent variable&quot; = function(e) e$dep_var &lt;- e$data[[1]] &gt; 5,
  &quot;Create derived variable&quot;   = function(e) e$diff &lt;- e$data[[1]] - e$data[[2]]
))
</code></pre>

<p>Now, the stagerunner holds a copy of the full environment in each stage:
this means we can re-run previous stages at will.</p>

<pre><code class="r">runner$run()        # Run all stages
runner$data &lt;- NULL # Clear the data
runner$run(2)       # Re-run just the second stage.
</code></pre>

<p>In this scenario, the <code>data</code> gets restored from a cached environment&ndash;
what the context looked like after the first stage finished&ndash;
and we have a <code>dep_var</code> column (although no <code>diff</code> column since
the third stage was now &ldquo;rolled back&rdquo;).</p>

<p>This kind of approach also allows us to debug what happens during execution:</p>

<pre><code class="r">envs &lt;- runner$run(2)
ls(envs$before$data) # The iris attributes
ls(envs$after$data)  # The iris attributes *and* dep_var
</code></pre>

<p>When a stagerunner is set to remember its progress the output of the <code>run</code>
function consists of a list with keys <code>before</code> and <code>after</code> representing
two environments: what the stagerunner&#39;s context looked like before
and after executing that stage.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Run the stages in a stageRunner object.
#'
#' @param from an indexing parameter. Many forms are accepted, but the
#'   easiest is the name of the stage. For example, if we have
#'   \code{stageRunner$new(context, list(stage_one = some_fn, stage_two = some_other_fn))}
#'   then using \code{run('stage_one')} will execute \code{some_fn}.
#'   Additional indexing forms are logical (which stages to execute),
#'   numeric (which stages to execute by indices), negative (all but the
#'   given stages), character (as above), and nested forms of these.
#'   The latter refers to instances of the following:
#'   \code{stageRunner$new(context, list(stage_one =
#'     stageRunner$new(context, substage_one = some_fn, substage_two = other_fn),
#'     stage_two = another_fn))}.
#'   Here, the following all execute only substage_two:
#'   \code{run(list(list(FALSE, TRUE), FALSE))},
#'   \code{run(list(list(1, 2)))},
#'   \code{run('stage_one/substage_two')},
#'   \code{run('one/two')},
#'   Notice that substrings are allowed for characters.
#'   The default is \code{NULL}, which runs the whole sequences of stages.
#' @param to an indexing parameter. If \code{from} refers to a single stage,
#'   attempt to run from that stage to this stage (or, if this one comes first,
#'   this stage to that stage). For example, if we have
#'      \code{stages = list(a = list(b = 1, c = 2), d = 3, e = list(f = 4, g = 5))}
#'   where the numbers are some functions, and we call \code{run} with
#'   \code{from = 'a/c'} and \code{to = 'e/f'}, then we would execute
#'   stages \code{"a/c", "d", "e/f"}.
#' @param verbose logical. Whether or not to display pretty colored text
#'   informing about stage progress.
#'   nested list of logicals.
#' @param remember_flag logical. An internal argument used by \code{run}
#'   recursively if the \code{stageRunner} object has the \code{remember}
#'   field set to \code{TRUE}. If \code{remember_flag} is FALSE, \code{run}
#'   will not attempt to restore the context from cache (e.g., if we are
#'   executing five stages simultaneously with \code{remember = TRUE},
#'   the first stage's context should be restored from cache but none
#'   of the remaining stages should).
#' @param mode character. If \code{mode = 'head'}, then by default the
#'   \code{from} parameter will be used to execute that stage and that
#'   stage only. If \code{mode = 'next'}, then the \code{from} parameter
#'   will be used to run (by default, if \code{to} is left missing)
#'   from the last successfully executed stage to the stage given by
#'   \code{from}. If \code{from} occurs before the last successfully
#'   executed stage (say S), the stages will be run from \code{from} to S.
#' @param normalized logical. A convenience recursion performance helper. If
#'   \code{TRUE}, stageRunner will assume the \code{from} argument is a
#'   nested list of logicals.</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Do not worry about this parameter, <code>.depth</code>.
It is used internally to keep track of how &ldquo;deep&rdquo; the current stage execution is.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' @param .depth integer. Internal parameter for keeping track of nested
#'   execution depth.
#' @param ... Any additional arguments to delegate to the \code{stageRunnerNode}
#'   object that will execute its own \code{run} method.
#'   (See \code{stageRunnerNode$run})
#' @return TRUE or FALSE according as running the stages specified by the
#'   \code{from} and \code{to} keys succeeded or failed. If
#'   \code{remember = TRUE}, this will instead be a list of the environment
#'   before and after executing the aforementioned stages. (This allows
#'   comparing what changes were made to the \code{context} during the
#'   execution of the stageRunner.)
#' @examples
#' env <- new.env()
#' some_fn    <- function(e) e$x <- 1
#' other_fn   <- function(e) e$y <- 1
#' another_fn <- function(e) e$z <- 1
#' sr <- stagerunner(env, list(stage_one =
#'  stagerunner(env, list(substage_one = some_fn, substage_two = other_fn)),
#'  stage_two = another_fn))
#' 
#' # Here, the following all execute only substage_two:
#'
#' sr$run(list(list(FALSE, TRUE), FALSE))
#' sr$run(list(list(1, 2)))
#' sr$run('stage_one/substage_two')
#' sr$run('one/two')
#' stopifnot(is.null(env$z), is.null(env$x), identical(env$y, 1))
#'
#' # This will execute all but "stage_one" (i.e., only "stage_two")
#' sr$run(-1)
#' stopifnot(identical(env$z, 1))
run <- function(from = NULL, to = NULL, verbose = FALSE, remember_flag = TRUE,
                mode = self$.mode, normalized = FALSE, .depth = 1, ...) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>The parameter <code>normalized</code> refers to whether the input (that is, the <code>from</code>
and <code>to</code> parameters) are in the canonical nested list format. For example,
if we have a runner with stages &ldquo;Import&rdquo;, &ldquo;Data/impute&rdquo;, and
&ldquo;Data/discretize&rdquo;, the canonical representation for the first substage
of the second stage would be <code>list(FALSE, list(TRUE, FALSE))</code>. This allows
the stagerunner package to easily tell what is being executed.</p>

<p>If the <code>from</code> and <code>to</code> parameters are not in normal form, or the <code>from</code>
parameter is missing and the <code>to</code> parameter is present (so that we
are asking to run from the beginning to the stage denoted by <code>to</code>),
we must first normalize the keys to use this nested list format.</p>

<p>We will use the <code>stage_key</code> local variable to track what substages
to execute during this <code>run</code> call.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (identical(normalized, FALSE)) {
    if (missing(from) && identical(self$remember, TRUE) && identical(mode, 'next')) {
      from <- self$next_stage()
      if (missing(to)) to <- TRUE
    }
    stage_key <- normalize_stage_keys(from, self$stages, to = to)
  } else {
    stage_key <- from
  }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Now that we have determined which stages to run, we cycle through them all.
It is up to the user to determine that context changes make sense.
We also implicitly sort the stages to ensure linearity is preserved.
Stagerunner enforces the linearity and directionality set in the stage
definitions.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  </span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If we are remembering changes, we must recall what the environment looked
like <em>before</em> we ran anything.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  before_env <- NULL

  for (stage_index in seq_along(stage_key)) {
    nested_run <- TRUE
    </span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>In a stagerunner, recursively nested stages (i.e., stages with substages)
are themselves represented as stagerunners, while final stages
(i.e., the functions to execute) are represented as <a href="http://cran.r-project.org/web/packages/R6/index.html">R6</a>
objects called <code>stageRunnerNode</code>s. In each scenario, a different
recursive call to <code>$run</code> will be necessary, so we compute a 
closure that gives the correct call for later use.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    run_stage <- determine_run_stage(stage_key, stage_index,
                                     self$stages, verbose, .depth)
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We keep track of whether this is a nested run so that the verbose
display knows whether to say &ldquo;<em>Beginning</em> stage X&rdquo; or &ldquo;<em>Running</em> stage X&rdquo;.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    if (isTRUE(stage_key[[stage_index]]) &&
        !is.stagerunner(self$stages[[stage_index]])) {
      nested_run <- FALSE
    }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>The above helper <code>run_stage</code> will return an object of class <code>next_stage</code>
if we should skip this stage (i.e., because <code>stage_key[[stage_index]]</code>
is <code>FALSE</code>).</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    if (is(run_stage, "next_stage")) next
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Display a nice message telling us which stage we are currently
executing.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    display_message <- isTRUE(verbose) && contains_true(stage_key[[stage_index]])
    if (display_message) {
      show_message(names(self$stages), stage_index, begin = TRUE,
                   nested = nested_run, depth = .depth)
    }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If <code>remember = TRUE</code>, we have to cache the progress along each stage.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    if (self$remember && isTRUE(remember_flag) && is.null(before_env)) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If we have not determined what the environment on the stagerunner
was like prior to running any stages, we do so now. This will
eventually be returned by this function, so that the user
can inspect what happened before and after all the desired
stages were executed.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">      if (nested_run) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If this is a nested stage, we grab the &ldquo;initial environment&rdquo;
recursively.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">        before_env <- run_stage(..., remember_flag = TRUE)$before
      } else { </span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Otherwise, if it is a terminal node, we just make a copy of
the current context.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">        before_env <- self$.before_env(stage_index)
      }
      </span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If the current stage is a terminal node,
execute the stage (if it was nested, it&#39;s already been
executed in order to recursively fetch the initial environment,
<code>before_env</code>).</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">      if (!nested_run) { run_stage(...) }
    }
    else if (self$remember) { run_stage(..., remember_flag = FALSE) }
    else { run_stage(...) }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>When we&#39;re done running a stage (i.e., processing a terminal node),
set the cache on the successor node to be the current context
(since that node will execute starting with what&#39;s in the context now &ndash;
this also ensures that running that node with a separate call to
<code>$run</code> will not bump into a &ldquo;you haven&#39;t executed this stage yet&rdquo; error).</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    if (self$remember && !nested_run) {
      self$.mark_finished(stage_index)
    }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Finally, display our progress by indicating we are ending this stage.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    if (display_message) {
      show_message(names(self$stages), stage_index, begin = FALSE,
                   nested = nested_run, depth = .depth)
    }
  }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If the stagerunner is a <em>remembering</em> stagerunner, i.e., the field
<code>remember = TRUE</code>, we will return a list with keys <code>before</code> and <code>after</code>
indicating what the stagerunner&#39;s context looked like before and after
executing the stages indicated by the <code>from</code> and <code>to</code> parameters.
This allows the user to perform their own analysis about what happened.</p>

<p>Otherwise, we simply return <code>TRUE</code> (<a href="http://stackoverflow.com/questions/11653127/what-does-the-function-invisible-do">invisibly</a>).</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (self$remember && remember_flag) {
    list(before = before_env, after = self$.context)
  } else {
    invisible(TRUE)
  }
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>This is a helper function to call <code>$run</code> correctly if we are recursively
executing substages:</p>

<ul>
<li>If the substage is a stagerunner, pass along information about how
deep we currently are in the stagerunner for verbose printing.</li>
<li>Otherwise, simply call the <code>stageRunnerNode$run</code> method directly.</li>
</ul>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">determine_run_stage <- function(stage_key, stage_index, stages, verbose, .depth) {
  if (isTRUE(stage_key[[stage_index]])) {
    stage <- stages[[stage_index]]
    if (is.stagerunner(stage)) { 
      function(...) { stage$run(verbose = verbose, .depth = .depth + 1, ...) }
    } else {
     nested_run <- FALSE</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Intercept the <code>remember_flag</code> argument to calls to the <code>stageRunnerNode</code>
(since it doesn&#39;t know how to use it).</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">     function(..., remember_flag = TRUE) { stage$run(...) }
    }
  } else if (is.list(stage_key[[stage_index]])) {
    if (!is.stagerunner(stages[[stage_index]])) {
      stop("Invalid stage key: attempted to make a nested stage reference ",
           "to a non-existent stage")
    }

    function(...) {
      stages[[stage_index]]$run(stage_key[[stage_index]], normalized = TRUE,
                                verbose = verbose, .depth = .depth + 1, ...)
    }
  } else {
    structure(list(), class = "next_stage")
  }
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-show.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Generic for printing stageRunner objects.
#' 
#' @name stageRunner_show
#' @param indent integer. Internal parameter for keeping track of nested
#'   indentation level.
stageRunner_show <- function(indent = 0) {
  if (missing(indent)) {
    sum_stages <- function(x) sum(vapply(x,
      function(x) if (is.stagerunner(x)) sum_stages(x$stages) else 1L, integer(1)))
    caching <- if (self$remember) ' caching' else ''
    cat("A", caching, " stageRunner with ", sum_stages(self$stages), " stages:\n", sep = '')
  }
  stage_names <- names(self$stages) %||% rep("", length(self$stages))

  # A helper function for determining if a stage has been run yet.
  began_stage <- function(stage)
    if (is.stagerunner(stage)) any(vapply(stage$stages, began_stage, logical(1)))
    else if (is.stageRunnerNode(stage)) !is.null(stage$.cached_env)
    else FALSE

  lapply(seq_along(stage_names), function(index) {
    prefix <- paste0(rep('  ', (if (is.numeric(indent)) indent else 0) + 1), collapse = '')
    marker <-
      if (self$remember && began_stage(self$stages[[index]])) {
        next_stage <- treeSkeleton$new(self$stages[[index]])$last_leaf()$successor()$object
        if (( is.null(next_stage) && !self$.root()$.finished) ||
            (!is.null(next_stage) && !began_stage(next_stage))) 
          '*' # Use a * if this is the next stage to be executed
          # TODO: Fix the bug where we are unable to tell if the last stage
          # finished without a .finished internal field.
          # We need to look at and set predecessors, not successors.
        else '+' # Other use a + for completely executed stage
      } else '-'
    prefix <- gsub('.$', marker, prefix)
    stage_name <- 
      if (is.na(stage_names[[index]]) || stage_names[[index]] == "")
        paste0("< Unnamed (stage ", index, ") >")
      else stage_names[[index]]
    cat(prefix, stage_name, "\n")
    if (is.stagerunner(self$stages[[index]]))
      self$stages[[index]]$show(indent = indent + 1)
  })

  if (missing(indent)) { cat('Context '); print(self$.context) }
  NULL
}

#' @export
print.stageRunner <- function(x, ...) {
  x$show(...)
}

#' @export
print.stageRunnerNode <- function(x, ...) {
  x$show(...)
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-stage_names.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Retrieve a flattened list of canonical stage names for a stageRunner object
#'
#' For example, if we have stages
#'   \code{stages = list(a = list(b = 1, c = 2), d = 3, e = list(f = 4, g = 5))}
#' then this method would return
#'   \code{list('a/b', 'a/c', 'd', 'e/f', 'e/g')}
#'
#' @name stageRunner_stage_names
#' @return a list of canonical stage names.
# # @examples
# # f <- function() {}
# # sr <- stageRunner$new(new.env(),
# #   list(a = stageRunner$new(new.env(), list(b = f, c = f)), d = f,
# #   e = stageRunner$new(new.env(), list(f = f, g = f))))
# # sr$stage_names()
stageRunner_stage_names <- function() {
  nested_stages <- function(x) if (is.stagerunner(x)) nested_stages(x$stages) else x
  nested_names(lapply(self$stages, nested_stages))
}

</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-transform.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Transform the callable's of the terminal nodes of a stageRunner.
#'
#' Every terminal node in a stageRunner is of type stageRunnerNode.
#' These each have a callable, and this method transforms those
#' callables in the way given by the first argument.
#'
#' @name stageRunner_transform
#' @param transformation function. The function which transforms one callable
#'   into another.
stageRunner_transform <- function(transformation) {
  for (stage_index in seq_along(self$stages))
    self$stages[[stage_index]]$transform(transformation)
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stageRunnerNode.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Stagerunner nodes are environment wrappers around individual stages
#' (i.e. functions) in order to track meta-data (e.g., for caching).
#' 
#' @param fn function. This will be wrapped in an environment.
#' @param parent_obj stageRunner. The enclosing stageRunner object.
#' @param parent_env environment. The parent environment of the created
#'   \code{stageRunnerNode} object. The default is the calling
#'   environment (i.e., \code{parent.frame()}).
#' @return an environment with some additional attributes for
#'   navigating in a tree-like structure.
#' @name stageRunnerNode
#' @format NULL
#' @docType class
stageRunnerNode_ <- R6::R6Class('stageRunnerNode',
  public = list(
    callable = NULL,
    .cached_env = NULL,
    .context = NULL,
    .parent = NULL,
    executed = FALSE,
    initialize = function(.callable, .context = NULL) {
      stopifnot(is_any(.callable, c('stageRunner', 'function', 'NULL')))
      self$callable <- .callable
      self$.context <- .context
      self$executed <- FALSE
    },

    run = function(..., .cached_env = NULL, .callable = self$callable) {
      # TODO: Clean this up by using environment injection utility fn
      correct_cache <- .cached_env %||% self$.cached_env
      if (is.null(.callable)) FALSE
      else if (is.stagerunner(.callable)) {
        .callable$run(..., .cached_env = correct_cache)
      } else {
        tmp <- new.env(parent = environment(.callable))
        environment(.callable) <- tmp
        environment(.callable)$cached_env <- correct_cache
        on.exit(environment(.callable) <- parent.env(environment(.callable)))
        .callable(self$.context, ...)
      }
      self$executed <- TRUE
    }, 

    # This function goes hand in hand with stageRunner$around
    around = function(other_node) {
      if (is.stageRunnerNode(other_node)) other_node <- other_node$callable
      if (is.null(other_node)) return(FALSE)
      if (!is.function(other_node)) {
        warning("Cannot apply stageRunner$around in a terminal ",
                "node except with a function. Instead, I got a ",
                class(other_node)[1])
        return(FALSE)
      }

      new_callable <- other_node
      # Inject yield() keyword
      yield_env <- new.env(parent = environment(new_callable))
      yield_env$.parent_context <- self
      yield_env$yield <- function() {
        # ... lives up two frames, but the run function lives up 1,
        # so we have to do something ugly
        run <- eval.parent(quote(.parent_context$run))
        args <- append(eval.parent(quote(list(...)), n = 2),
          list(.callable = callable))
        do.call(run, args, envir = parent.frame())
      }
      environment(yield_env$yield) <- new.env(parent = baseenv())
      environment(yield_env$yield)$callable <- self$callable

      environment(new_callable) <- yield_env
      self$callable <- new_callable
      TRUE
    },

    overlay = function(other_node, label = NULL, flat = FALSE) {
      if (is.stageRunnerNode(other_node)) other_node <- other_node$callable
      if (is.null(other_node)) return(FALSE)
      if (!is.stagerunner(other_node)) 
        other_node <- stageRunner$new(self$.context, other_node)

      # Coerce the current callable object to a stageRunner so that
      # we can append the other_node's stageRunner.
      if (!is.stagerunner(self$callable)) 
        self$callable <- stageRunner$new(self$.context, self$callable)

      # TODO: Fancier merging here
      if (isTRUE(flat)) {
        if (!is.character(label)) stop("flat coalescing needs a label")
        self$callable$stages[[label]] <- other_node
      } else self$callable$append(other_node, label)
    },
    transform = function(transformation) {
      if (is.stagerunner(self$callable)) self$callable$transform(transformation)
      else self$callable <- transformation(self$callable)
    },
    was_executed = function() { self$executed },
    parent   = function() { attr(self, "parent") }, # accessor_method(.parent),
    children = function() list(),
    show     = function() { cat("A stageRunner node containing: \n"); print(self$callable) },

    # Functions which intertwine with the objectdiff package
    index    = function() {
      ix <- which(vapply(attr(self, "parent")$stages,
        function(x) identical(self, x), logical(1)))
      paste0(attr(self, "parent")$.prefix, ix)
    }
  )
)

#' @export
stageRunnerNode <- structure(
  function(...) { stageRunnerNode_$new(...) },
  class = "stageRunnerNode_"
)

#' @export
`$.stageRunnerNode_` <- function(...) {
  stopifnot(identical(..2, "new"))
  ..1
}

#' @export
#' @rdname stageRunnerNode
is.stageRunnerNode <- function(obj) inherits(obj, 'stageRunnerNode')
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>tree_skeleton.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Initialize a treeSkeleton object.
#'
#' treeSkeleton objects allow you to traverse a reference class object
#' as if it had a tree structure, merely by knowing how to call parent
#' or child nodes.
#'
#' @name treeSkeleton__initialize
#' @param object ANY. If a reference class object, then \code{parent_caller}
#'    and \code{children_caller} will refer to reference class methods.
#'    If an attribute on the object with names of \code{children_caller} and
#'    \code{parent_caller} exists, those will be used. Otherwise, the
#'    generic methods will be used.
#' @param parent_caller character. The name of the reference class method
#'    that returns the parent object, if the object was a node in a tree
#'    structure.
#' @param children_caller character. The name of the reference class method
#'    that returns the child objects, if the object was a node in a tree
#'    structure.
#' @return a treeSkeleton object.
treeSkeleton__initialize <- function(object, parent_caller = 'parent',
                                     children_caller = 'children') {
  stopifnot(!is.null(object))
  self$object  <- object
  self$.parent   <- uninitialized_field()
  self$.children <- uninitialized_field()

  # Make sure parent_caller and children_caller are methods of object
  if (inherits(object, "R6")) {
    stopifnot(all(c(parent_caller, children_caller) %in% ls(object)))
  }

  self$parent_caller   <- parent_caller
  self$children_caller <- children_caller
  NULL
}

#' Attempt to find the successor of the current node.
#'
#' @name treeSkeleton__successor
#' @param index integer. If specified, this is the index of the current node
#'   in the children of its parent. (Sometimes, this cannot be computed
#'   automatically, and should usually be provided.)
#' @return successor for the wrapped object.
treeSkeleton__successor <- function(index = NULL) {
  if (is.null(p <- self$parent())) return(NULL) # no successor of root node

  parent_index <- if (is.null(index)) self$.parent_index() else index
  stopifnot(is.finite(parent_index))

  # If we are the last leaf in the list of our parent's children,
  # our successor is our parent's successor
  if (parent_index == length(p$children()))
    p$successor()
  else
    p$children()[[parent_index + 1]]$first_leaf()
}


#' Find the root node of the tree (the only one with no parent).
#'
#' @name treeSkeleton__root
#' @return The root node of the tree or NULL if empty tree.
treeSkeleton__root <- function() {
  if (is.null(self$parent())) self
  else self$parent()
}

#' Find the first leaf in a tree.
#'
#' @name treeSkeleton__first_leaf
#' @return The first leaf, that is, the first terminal child node.
treeSkeleton__first_leaf <- function() {
  if (length(self$children()) == 0) self
  else self$children()[[1]]$first_leaf()
}

#' Find the last leaf in a tree.
#'
#' @name treeSkeleton__last_leaf
#' @return The last leaf, that is, the last terminal child node.
treeSkeleton__last_leaf <- function() {
  if (length(childs <- self$children()) == 0) self
  else childs[[length(childs)]]$last_leaf()
}

#' Find the parent of the current object wrapped in a treeSkeleton.
#' @name treeSkeleton__parent
treeSkeleton__parent <- function() {
  if (!is.unitialized_field(self$.parent)) return(self$.parent)
  self$.parent <-
    if (is.null(obj <- OOP_type_independent_method(self$object, self$parent_caller))) NULL
    else treeSkeleton$new(obj, parent_caller = self$parent_caller,
                          children_caller = self$children_caller)
}

#' Find the children of the current object wrapped in treeSkeletons.
#' @name treeSkeleton__children
treeSkeleton__children <- function() {
  if (!is.unitialized_field(self$.children)) return(self$.children)
  prechildren <- OOP_type_independent_method(self$object, self$children_caller)
  self$.children <- lapply(prechildren, treeSkeleton$new,
                       parent_caller = self$parent_caller)
}

#' Find the index of the current object in the children of its parent.
#' @name treeSkeleton__.parent_index
treeSkeleton__.parent_index <- function() {
  if (!is.null(ci <- attr(self$object, 'child_index'))) ci
  # Hack for accessing attribute modifications on a reference class object
  # See: http://stackoverflow.com/questions/22752021/why-is-r-capricious-in-its-use-of-attributes-on-reference-class-objects
  else if (is.refClass(self$object) &&
           !is.null(ci <- attr(attr(self$object, '.xData')$.self, 'child_index'))) ci
  else # look through the parent's children and compare to .self
    # Danger Will Robinson! This will lead to strange bugs if our tree
    # has several nodes with duplicate objects
    which(vapply(
      self$parent()$children(),
      function(node) identical(node$object, self$object), logical(1)))[1]
}

#' Find the key with the given index using the names of the lists
#' that parametrize each node's children.
#'
#' For example, if our tree structure is given by
#'   \code{list(a = list(b = 1, c = 2))}
#' then calling \code{find('a/b')} on the root node will return \code{1}.
#'
#' @name treeSkeleton__find
#' @param key character. The key to find in the given tree structure,
#'    whether nodes are named by their name in the \code{children()}
#'    list. Numeric indices can be used to refer to unnamed nodes.
#'    For example, if key is \code{a/2/b}, this method would try to find
#'    the current node's child \code{a}'s second child's \code{b} child.
#'    (Just look at the examples).
#' @return the subtree or terminal node with the given key.
#' @examples 
#' \dontrun{
#' sr <- stageRunner$new(new.env(), list(a = list(force, list(b = function(x) x + 1))))
#' stagerunner:::treeSkeleton$new(sr)$find('a/2/b') # function(x) x + 1
#' }
treeSkeleton__find <- function(key) {
#  stopifnot(is.character(key))
#  if (length(key) == 0 || identical(key, '')) return(self$object)
#  # Extract "foo" from "foo/bar/baz"
#  subkey <- regmatches(key, regexec('^[^/]+', key))[[1]]
#  key_remainder <- substr(key, nchar(subkey) + 2, nchar(key))
#  if (grepl('^[0-9]+', subkey)) {
#    subkey <- as.integer(subkey)
#    key_falls_within_children <- length(self$children()) >= subkey
#    stopifnot(key_falls_within_children)
#  } else {
#    matches <- grepl(subkey, names(self$children()))
#    stopifnot(length(matches) == 1)
#    key <- which(matches)
#  }
#  self$children()[[key]]$find(key_remainder)
}

#' This class implements iterators for a tree-based structure
#' without an actual underlying tree.
#'
#' In other dynamic languages, this kind of behavior would be called
#' duck typing. Imagine we have an object \code{x} that is of some
#' reference class. This object has a tree structure, and each node
#' in the tree has a parent and children. However, the methods to
#' fetch a node's parent or its children may have arbitrary names.
#' These names are stored in \code{treeSkeleton}'s \code{parent_caller}
#' and \code{children_caller} fields. Thus, if \code{x$methods()}
#' refers to \code{x}'s children and \code{x$parent_method()} refers
#' to \code{x}'s parent, we could define a \code{treeSkeleton} for
#' \code{x} by writing \code{treeSkeleton$new(x, 'parent_method', 'methods')}.
#'
#' The iterators on a \code{treeSkeleton} use the standard definition of
#' successor, predecessor, ancestor, etc.
#'
#' @name treeSkeleton
#' @docType class
#' @format NULL
treeSkeleton_ <- R6::R6Class('treeSkeleton',
  public = list(
    object = 'ANY',
    parent_caller = 'character',
    children_caller = 'character',
    .children = 'ANY',
    .parent = 'ANY',

    initialize    = stagerunner:::treeSkeleton__initialize,
    successor     = stagerunner:::treeSkeleton__successor,
    # TODO: I don't need any more iterators, but maybe implement them later
    #predecessor  = stagerunner:::treeSkeleton__predecessor,
    parent        = stagerunner:::treeSkeleton__parent,
    children      = stagerunner:::treeSkeleton__children,
    root          = stagerunner:::treeSkeleton__root,
    first_leaf    = stagerunner:::treeSkeleton__first_leaf,
    last_leaf     = stagerunner:::treeSkeleton__last_leaf,
    find          = stagerunner:::treeSkeleton__find,
    .parent_index = stagerunner:::treeSkeleton__.parent_index,
    show          = function() { cat("treeSkeleton wrapping:\n"); print(self$object) }
  )
)

#' @export
treeSkeleton <- structure(
  function(...) { treeSkeleton_$new(...) },
  class = "treeSkeleton_"
)

#' @export
`$.treeSkeleton_` <- function(...) {
  stopifnot(identical(..2, "new"))
  ..1
}

uninitialized_field <- function() {
  structure(NULL, class = "uninitialized_field")
}

is.unitialized_field <- function(x) {
  is(x, "uninitialized_field")
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>utils.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">`%||%` <- function(x, y) if (is.null(x)) y else x

contains_true <- function(x) {
  if (is.list(x)) any(vapply(x, contains_true, logical(1)))
  else any(x)
}

all_logical <- function(x) {
  is.logical(x) || all(vapply(x,
    function(y) if (is.atomic(y)) is.logical(y) else all_logical(y),
  logical(1)))
}

as.ordinal <- function(number) {
  ordinals <- list('first', 'second', 'third', 'fourth', 'fifth',
    'sixth', 'seventh', 'eighth', 'ninth', 'tenth', 'eleventh',
    'twelfth', 'thirteenth', 'fourteenth', 'fifteenth',
    'sixteenth', 'seventeenth', 'eighteenth', 'nineteenth',
    'twentieth')
  ext <- c("th", "st", "nd", "rd", rep("th", 6))
  ordinals[number][[1]] %||%
  paste0(number, ext[[(number %% 10) + 1]])
}

enforce_type <- function(value, expected, klass, name = deparse(substitute(value))) {
  if (missing(value)) {
    stop(sprintf(
      "Please provide %s%s.",
      articleize(sQuote(crayon::red(name))),
      if (missing(klass)) "" else paste( " to a", klass)
    ))
  }

  check <- utils::getFromNamespace(paste0("is.", expected), "base")
  if (!check(value)) {
    stop(sprintf(
      "Please pass %s as the %s%s; instead I got a %s.",
      articleize(sQuote(crayon::yellow(expected))), dQuote(name),
      if (missing(klass)) "" else paste(" for a", klass),
      crayon::red(sclass(value))
    ))
  }
}

sclass <- function(obj) { class(obj)[1L] }

articleize <- function(word) {
  sprintf("a%s %s", if (is_vowel(first_letter(word))) "n" else "", word)
}

is_vowel <- function(char) {
  is.element(char, c("a", "e", "i", "o", "u", "A", "E", "I", "O", "U"))
}

first_letter <- function(word) {
  substring(gsub("[^a-zA-Z]|\\[3[0-9]m", "", word), 1, 1)
}

# Whether obj is of any of the given types.
is_any <- function(obj, klasses) {
  any(vapply(klasses, inherits, logical(1), x = obj))
}

package_function <- function(pkg, fn) { # for when using :: breaks R CMD check
  get(fn, envir = getNamespace(pkg))
}

#' Call a method on an object regardless of its OOP type.
#'
#' @name OOP_type_independent_method 
#' @param object any. An R object of variable OOP type (S3, S4, RC, R6).
#' @param method character. The method to call on the \code{object}. If the
#'    latter is a reference class, it use the \code{$} operator to access the method.
#'    (For example, \code{object$some_method}). If it has an attribute with the name
#'    \code{method}, it will use that attribute as the method to call. Otherwise,
#'    it will try to fetch a generic with the name \code{method} using \code{get}.
OOP_type_independent_method <- function(object, method) {
  if (method %in% names(attributes(object))) {
    attr(object, method)
  } else if (is.environment(object) && method %in% ls(object)) {
    object[[method]]()
  } else {
    get(method)(object)
  }
}

# Convert an environment to a list
as.list.environment <- function(env) {
  out <- base::as.list.environment(env)
  lapply(out, function(x) if (is.environment(x)) as.list(x) else x)
}
</span></code>
            </pre>
          </div>
        </div>
      <div class="section">
      </div>

    </div>
  </body>
</html>
