% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/tree_skeleton.r
\docType{data}
\name{treeSkeleton}
\alias{treeSkeleton}
\alias{treeSkeleton_}
\title{This class implements iterators for a tree-based structure
without an actual underlying tree.}
\format{\preformatted{List of 8
 $ new       :function (...)  
 $ classname : chr "treeSkeleton"
 $ public    :List of 15
  ..$ object         : chr "ANY"
  ..$ parent_caller  : chr "character"
  ..$ children_caller: chr "character"
  ..$ .children      : chr "ANY"
  ..$ .parent        : chr "ANY"
  ..$ initialize     :function (object, parent_caller = "parent", children_caller = "children")  
  .. ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 20 29 37 1 29 1 20 37
  .. .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x11098ab80> 
  ..$ successor      :function (index = NULL)  
  .. ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 46 28 58 1 28 1 46 58
  .. .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x11098ab80> 
  ..$ parent         :function ()  
  .. ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 90 25 96 1 25 1 90 96
  .. .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x11098ab80> 
  ..$ children       :function ()  
  .. ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 100 27 105 1 27 1 100 105
  .. .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x11098ab80> 
  ..$ root           :function ()  
  .. ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 65 23 68 1 23 1 65 68
  .. .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x11098ab80> 
  ..$ first_leaf     :function ()  
  .. ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 74 29 77 1 29 1 74 77
  .. .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x11098ab80> 
  ..$ last_leaf      :function ()  
  .. ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 83 28 86 1 28 1 83 86
  .. .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x11098ab80> 
  ..$ find           :function (key)  
  .. ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 143 23 159 1 23 1 143 159
  .. .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x11098ab80> 
  ..$ .parent_index  :function ()  
  .. ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 109 32 121 1 32 1 109 121
  .. .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x11098ab80> 
  ..$ show           :function ()  
  .. ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 198 21 198 86 21 86 198 198
  .. .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x11098ab80> 
 $ private   : NULL
 $ active    : NULL
 $ inherit   : NULL
 $ parent_env:<environment: namespace:stagerunner> 
 $ lock      : logi TRUE
 - attr(*, "class")= chr "R6ClassGenerator"
}}
\usage{
treeSkeleton_
}
\description{
In other dynamic languages, this kind of behavior would be called
duck typing. Imagine we have an object \code{x} that is of some
reference class. This object has a tree structure, and each node
in the tree has a parent and children. However, the methods to
fetch a node's parent or its children may have arbitrary names.
These names are stored in \code{treeSkeleton}'s \code{parent_caller}
and \code{children_caller} fields. Thus, if \code{x$methods()}
refers to \code{x}'s children and \code{x$parent_method()} refers
to \code{x}'s parent, we could define a \code{treeSkeleton} for
\code{x} by writing \code{treeSkeleton$new(x, 'parent_method', 'methods')}.
}
\details{
The iterators on a \code{treeSkeleton} use the standard definition of
successor, predecessor, ancestor, etc.
}
\keyword{datasets}

